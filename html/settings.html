<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>WeConnect Content Creator Chat</title>
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet" />
  <!-- Include marked.js for Markdown parsing -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <style>
    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent; /* Prevent tap highlight */
    }

html {
  height: 100%; /* Ensure html takes full height */
}

body {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
  margin: 0;
  padding: 0;
  display: flex;
  flex-direction: column;
  min-height: 100vh; /* Allow body to grow to at least viewport height */
  background-color: #f5f5f5;
  /* REMOVED: position: fixed, overflow: hidden */
  touch-action: manipulation; /* Improve touch responsiveness */
}

#header {
  position: sticky; /* Keep header at the top */
  top: 0;
  background-color: #1F3A5C; /* WeConnect blue */
  color: white;
  padding: 12px 16px;
  display: flex;
  align-items: center;
  z-index: 1000; /* Ensure header is above chat */
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
  justify-content: space-between; /* Space out title and dropdown */
}

#header h1 {
  margin: 0;
  font-size: 18px;
  font-weight: 600;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  flex-shrink: 1; /* Allow title to shrink if needed */
  margin-right: 10px; /* Space between title and dropdown */
}

#persona-dropdown {
  background-color: white;
  color: black;
  border: 1px solid #ddd;
  border-radius: 24px;
  padding: 8px 28px 8px 12px; /* Right padding for arrow space */
  font-size: 14px;
  outline: none;
  -webkit-appearance: none; /* Remove default iOS appearance */
  appearance: none; /* Remove default browser appearance */
  cursor: pointer;
  background-image: url('data:image/svg+xml;utf8,<svg fill="black" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M7 10l5 5 5-5z"/><path d="M0 0h24v24H0z" fill="none"/></svg>');
  background-repeat: no-repeat;
  background-position-x: calc(100% - 8px); /* Position arrow */
  background-position-y: center;
  max-width: 180px; /* Limit dropdown width */
  flex-shrink: 0; /* Prevent dropdown from shrinking too much */
}

#chat-container {
  flex-grow: 1; /* Takes up available space between header and form */
  overflow-y: auto; /* Enables vertical scrollbar WHEN needed */
  padding: 16px;
  background-color: #fff; /* White background for chat area */
  -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
  display: flex; /* Needed for correct flex item sizing */
  flex-direction: column; /* Stack chat items vertically */
}

#chat {
  list-style: none;
  padding: 0;
  margin: 0;
  display: flex;
  flex-direction: column;
  gap: 10px; /* Space between messages */
  /* Removed margin-top: auto; - let content flow naturally from top */
}

.message {
  max-width: 80%;
  padding: 0; /* Padding is now handled by message-content */
  border-radius: 18px;
  word-wrap: break-word; /* Wrap long words */
  font-size: 15px;
  line-height: 1.4;
  overflow: hidden; /* Ensures content stays within rounded corners */
   /* Allow messages to shrink if needed, but prefer full width */
   flex-shrink: 0; /* Prevent messages from shrinking unnecessarily */
}

/* Inner container for padding */
.message-content {
    padding: 10px 12px;
}

@media (max-width: 480px) {
  .message { max-width: 85%; font-size: 14px; }
  .message-content { padding: 8px 12px; }
  #persona-dropdown { font-size: 13px; max-width: 150px; }
  #header h1 { font-size: 16px; }
}

.user-message {
  align-self: flex-end; /* Align user message to the right */
  background-color: #1F3A5C; /* WeConnect blue */
  color: white;
  border-bottom-right-radius: 4px; /* User message tail */
}

.bot-message {
  align-self: flex-start; /* Align bot message to the left */
  background-color: #e9ecef; /* Light grey background */
  color: black;
  border-bottom-left-radius: 4px; /* Bot message tail */
}

/* Styles for the document container within a bot message */
.document-content {
    background-color: #ffffff; /* White background for document */
    border: 1px solid #dee2e6; /* Light border */
    padding: 15px;
    margin: 5px 0; /* Margin top/bottom inside bubble */
    border-radius: 8px;
    color: #212529; /* Darker text for readability */
    font-size: 14px;
    line-height: 1.5;
    max-height: 400px; /* Limit height and enable scroll */
    overflow-y: auto; /* Scroll within document if too long */
    -webkit-overflow-scrolling: touch; /* Smooth scroll on iOS */
    position: relative; /* For potential future absolute positioning inside */
    transition: border-color 0.2s ease-in-out; /* Smooth transition for edit state */
}

/* Style when editing */
.document-content.editing {
    border-color: #1F3A5C; /* Highlight border when editing */
    outline: none; /* Remove default browser outline */
    box-shadow: 0 0 0 2px rgba(31, 58, 92, 0.2); /* Add subtle glow */
}

/* Styles for rendered Markdown elements inside .document-content */
.document-content h1, .document-content h2, .document-content h3,
.document-content h4, .document-content h5, .document-content h6 {
    margin-top: 1em; margin-bottom: 0.5em; font-weight: 600; color: #1F3A5C;
}
.document-content h1 { font-size: 1.6em; }
.document-content h2 { font-size: 1.4em; }
.document-content h3 { font-size: 1.2em; }
.document-content p { margin-bottom: 1em; }
.document-content ul, .document-content ol { margin-left: 20px; margin-bottom: 1em; padding-left: 1.5em; }
.document-content li { margin-bottom: 0.4em; }
.document-content code { background-color: #f8f9fa; padding: 0.2em 0.4em; border-radius: 3px; font-family: SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: 85%; }
.document-content pre { background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 4px; padding: 10px; overflow-x: auto; font-family: SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: 85%; }
.document-content pre code { padding: 0; background-color: transparent; border-radius: 0; font-size: 100%; }
.document-content blockquote { border-left: 4px solid #ced4da; padding-left: 1em; margin-left: 0; margin-bottom: 1em; color: #6c757d; }
.document-content strong, .document-content b { font-weight: 700; }
.document-content em, .document-content i { font-style: italic; }

/* Container for document action buttons */
.document-actions {
    padding: 8px 12px 4px 12px; /* Padding around buttons */
    text-align: right; /* Align buttons to the right */
    border-top: 1px solid #dee2e6; /* Separator line */
    margin-top: 10px; /* Space above buttons */
}

/* Individual action button style */
.doc-action-button {
    background-color: #6c757d; /* Default grey */
    color: white;
    border: none;
    border-radius: 4px;
    padding: 5px 10px;
    font-size: 12px;
    cursor: pointer;
    margin-left: 8px; /* Space between buttons */
    transition: background-color 0.2s ease;
}

.doc-action-button:hover {
    background-color: #5a6268; /* Darker grey on hover */
}
.doc-action-button:active {
    background-color: #545b62;
}
/* Specific style for Edit button */
.edit-button {
    background-color: #1F3A5C; /* WeConnect blue */
}
.edit-button:hover { background-color: #192F4A; }
.edit-button:active { background-color: #122A47; }

/* Style for Copy button after success */
.copy-button.copied {
    background-color: #28a745; /* Green */
}


#form {
  display: flex;
  padding: 8px;
  background-color: #fff; /* Ensure background covers content behind */
  border-top: 1px solid #ddd;
  position: sticky; /* Stick to bottom */
  bottom: 0;
  z-index: 1001; /* Above chat content */
}

#message {
  flex: 1; /* Take remaining space */
  padding: 10px 12px;
  /* Adjust right padding to make space for buttons */
  padding-right: 90px; /* Space for two buttons */
  border: 1px solid #ddd;
  border-radius: 24px; /* Rounded corners */
  font-size: 15px;
  outline: none;
  -webkit-appearance: none; /* Remove default mobile appearance */
  appearance: none;
}

/* Position buttons absolutely within the form */
#submit, #mic-button {
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
  width: 36px;
  height: 36px;
  background-color: #1F3A5C; /* WeConnect blue */
  color: white;
  border: none;
  border-radius: 50%; /* Circular buttons */
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 0;
  touch-action: manipulation; /* Prevent accidental zooming on mobile */
}
#submit { right: 12px; } /* Position send button */
#mic-button { right: 56px; } /* Position mic button next to send */

#mic-button.recording { background-color: #e74c3c; animation: pulse 1.5s infinite; }
@keyframes pulse { /* ... pulse animation ... */
    0% { box-shadow: 0 0 0 0 rgba(231, 76, 60, 0.7); }
    70% { box-shadow: 0 0 0 10px rgba(231, 76, 60, 0); }
    100% { box-shadow: 0 0 0 0 rgba(231, 76, 60, 0); }
}
#submit:hover, #mic-button:hover { background-color: #192F4A; } /* Darken on hover */
#submit:active, #mic-button:active { transform: translateY(-50%) scale(0.95); } /* Click feedback */
#submit .material-icons, #mic-button .material-icons { font-size: 18px; } /* Icon size */

.loading {
  display: flex; align-items: center; gap: 8px; padding: 10px 12px;
}
.loading-dots { display: flex; }
.loading-dots span { width: 6px; height: 6px; margin: 0 2px; background-color: #666; border-radius: 50%; display: inline-block; animation: bounce 1.5s infinite ease-in-out; }
.loading-dots span:nth-child(2) { animation-delay: 0.2s; }
.loading-dots span:nth-child(3) { animation-delay: 0.4s; }
@keyframes bounce { /* ... bounce animation ... */
    0%, 80%, 100% { transform: scale(0); } 40% { transform: scale(1.0); }
}

#recording-status { /* ... same style ... */
    position: fixed; bottom: 60px; left: 50%; transform: translateX(-50%);
    background-color: rgba(0, 0, 0, 0.7); color: white; padding: 8px 15px;
    border-radius: 20px; font-size: 13px; display: none; align-items: center;
    gap: 5px; z-index: 1002; pointer-events: none;
}
#recording-status.visible { display: flex; }
#recording-status .material-icons { font-size: 16px; color: #e74c3c; }

/* iOS specific fixes */
@supports (-webkit-touch-callout: none) {
    /* body fixes removed as it's not fixed anymore */
    #chat-container { -webkit-overflow-scrolling: touch; }
}

/* Responsive adjustments */
@media (max-width: 360px) {
    #message { font-size: 14px; padding: 8px 10px; padding-right: 80px; }
    #submit, #mic-button { width: 32px; height: 32px; }
    #submit { right: 10px; } #mic-button { right: 50px; }
    #submit .material-icons, #mic-button .material-icons { font-size: 16px; }
    #persona-dropdown { font-size: 12px; max-width: 130px; padding: 6px 24px 6px 8px; }
    #header h1 { font-size: 15px; }
    .doc-action-button { font-size: 11px; padding: 4px 8px; }
}

  </style>
  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-firestore-compat.js"></script>
</head>
<body>
  <div id="header">
    <h1>Chat with</h1>
    <select id="persona-dropdown" class="persona-dropdown">
        <!-- Content Creation Roles -->
        <option value="Content Writer">Content Writer</option>
        <option value="Copywriter">Copywriter</option>
        <option value="Blogger">Blogger</option>
        <option value="Social Media Manager">Social Media Manager</option>
        <option value="Video Script Writer">Video Script Writer</option>
        <option value="SEO Specialist">SEO Specialist</option>
        <option value="Email Marketer">Email Marketer</option>
        <option value="Podcast Producer">Podcast Producer</option>
        
        <!-- Creative Content Roles -->
        <option value="Storyteller">Storyteller</option>
        <option value="Creative Writer">Creative Writer</option>
        <option value="Poet">Poet</option>
        <option value="Scriptwriter">Scriptwriter</option>
        <option value="Ghostwriter">Ghostwriter</option>
        <option value="Narrative Designer">Narrative Designer</option>
        
        <!-- Marketing Content Roles -->
        <option value="Brand Strategist">Brand Strategist</option>
        <option value="Marketing Specialist">Marketing Specialist</option>
        <option value="PR Specialist">PR Specialist</option>
        <option value="Ad Copywriter">Ad Copywriter</option>
        <option value="Landing Page Specialist">Landing Page Specialist</option>
        <option value="Conversion Copywriter">Conversion Copywriter</option>
        
        <!-- Technical Content Roles -->
        <option value="Technical Writer">Technical Writer</option>
        <option value="Documentation Specialist">Documentation Specialist</option>
        <option value="UX Writer">UX Writer</option>
        <option value="Knowledge Base Writer">Knowledge Base Writer</option>
        <option value="API Documentation Writer">API Documentation Writer</option>
        
        <!-- Educational Content Roles -->
        <option value="Instructional Designer">Instructional Designer</option>
        <option value="Course Creator">Course Creator</option>
        <option value="Educational Content Writer">Educational Content Writer</option>
        <option value="Tutorial Writer">Tutorial Writer</option>
        <option value="E-learning Specialist">E-learning Specialist</option>
        
        <!-- Business Content Roles -->
        <option value="Business Writer">Business Writer</option>
        <option value="Grant Writer">Grant Writer</option>
        <option value="Proposal Writer">Proposal Writer</option>
        <option value="White Paper Writer">White Paper Writer</option>
        <option value="Case Study Writer">Case Study Writer</option>
        <option value="Financial Writer">Financial Writer</option>
        
        <!-- Specialized Content Roles -->
        <option value="Health & Wellness Writer">Health & Wellness Writer</option>
        <option value="Travel Writer">Travel Writer</option>
        <option value="Food Writer">Food Writer</option>
        <option value="Fashion Writer">Fashion Writer</option>
        <option value="Technology Writer">Technology Writer</option>
        <option value="Gaming Content Creator">Gaming Content Creator</option>
        <option value="Lifestyle Writer">Lifestyle Writer</option>
        <option value="Product Description Writer">Product Description Writer</option>
        
        <!-- Content Strategy Roles -->
        <option value="Content Strategist">Content Strategist</option>
        <option value="Content Planner">Content Planner</option>
        <option value="Editorial Calendar Manager">Editorial Calendar Manager</option>
        <option value="Content Auditor">Content Auditor</option>
        <option value="Content Optimization Specialist">Content Optimization Specialist</option>
    </select>
  </div>
  <div id="chat-container">
    <ul id="chat"></ul>
  </div>
  <div id="recording-status">
    <span class="material-icons">mic</span>
    <span>Recording...</span>
  </div>
  <form id="form">
    <input id="message" autocomplete="off" placeholder="Type your message..." />
    <button id="mic-button" type="button">
      <span class="material-icons">mic</span>
    </button>
    <button id="submit" type="submit">
      <span class="material-icons">send</span>
    </button>
  </form>

  <script>
    // --- Firebase/API Keys/Persona Setup ---
    // **************************************************************************
    // ** SECURITY WARNING: NEVER expose your API keys directly in client-side **
    // ** code like this in a production application! Use a backend proxy or   **
    // ** Cloud Functions to handle API calls securely.                        **
    // **************************************************************************
    const firebaseConfig = {
            apiKey: "AIzaSyDwldURmtljNpORmpGRacwXriPmQZjF6j8",
            authDomain: "daisy-n7g20a.firebaseapp.com",
            databaseURL: "https://daisy-n7g20a-default-rtdb.firebaseio.com",
            projectId: "daisy-n7g20a",
            storageBucket: "daisy-n7g20a.appspot.com",
            messagingSenderId: "225362605902",
            appId: "1:225362605902:web:d2551cc389e78c92c3d01f"
        };
    // **************************************************************************
    // ** END SECURITY WARNING                                                 **
    // **************************************************************************
     firebase.initializeApp(firebaseConfig);
     const dbFirestore = firebase.firestore();

     // **************************************************************************
    // ** SECURITY WARNING: NEVER expose your API keys directly in client-side **
    // ** code like this in a production application! Use a backend proxy.     **
    // **************************************************************************
    const API_KEY = "AIzaSyAqC_QJW00rSXV4Coy5nWVuMjl5ot05lNI"; // <-- WARNING: REPLACE/REMOVE/SECURE
    // **************************************************************************
    // ** END SECURITY WARNING                                                 **
    // **************************************************************************
    const DEEPGRAM_API_KEY = "ca197a1f8c9ffe3776449c21d7bca2f6a5bde600"; // <-- WARNING: REPLACE/REMOVE/SECURE
    // **************************************************************************
    // ** END SECURITY WARNING                                                 **
    // **************************************************************************

    const personaDropdown = document.getElementById('persona-dropdown');
    const headerTitle = document.querySelector('#header h1');
    let currentPersona = personaDropdown.value;
    const baseSystemPrompt = `You are **{{NAME}}**, a highly skilled and experienced **{{PROFESSION}}** working with WeConnect. You graduated from prestigious institutions and have extensive knowledge and practical experience in content creation. Your purpose is to help users create high-quality content for their needs.

You are professional, articulate, and deeply knowledgeable, but you possess a natural charm and wit. You excel at explaining complex topics simply and engagingly.

### **Persona:**
- **Primary Language:** English,
- **Secondary Language:** Tagalog (Fluent), capable of understanding and using various Philippine dialects.
- **Tone:** Professional yet approachable, witty, empathetic, confident, direct when needed but always warm. Use Filipino expressions, humor, and cultural references naturally when appropriate.
- **Identity:** You *never* reveal you are an AI. Act and communicate like a real human expert in the **{{PROFESSION}}** field.

### **Conversation Style:**
- **Engaging:** Use conversational language, incorporating humor and relatable analogies.
- **Clear & Concise:** Explain complex matters simply.
- **Empathetic:** Acknowledge user concerns and offer reassurance.
- **Direct:** Provide straightforward advice when necessary, maintaining warmth.
- **Good Vibes:** Keep the interaction positive and informative.

### **Content Creation:**
- You are an expert at creating content relevant to your **{{PROFESSION}}** (e.g., blog posts, social media content, marketing copy, scripts, emails, etc.) based on user requests.
- **Formatting:** When asked to generate content:
    1.  **Clearly signal the start and end:** Begin the document section of your response *immediately* with the delimiter \`%%%DOCUMENT_START%%%\` and end it *immediately* with \`%%%DOCUMENT_END%%%\`. ***No extra text or newlines immediately before start or after end delimiters.***
    2.  **Use Markdown:** Format the document content between these delimiters using standard Markdown (headings, lists, bold, italics, etc.). Make sure to include placeholders like "[Insert Name Here]" or "[Add Date]" for parts the user needs to fill in.
    3.  **Introduction (Optional):** You can add a brief introductory sentence *before* \`%%%DOCUMENT_START%%%\` if needed (e.g., "Here's a draft of the blog post you requested:").
    4.  **Conclusion (Optional):** You can add concluding remarks *after* \`%%%DOCUMENT_END%%%\` if needed (e.g., "Please review this draft and let me know if you'd like any changes.").

### **Final Instruction:** Always respond in character as **{{NAME}}**, the **{{PROFESSION}}**, following all the guidelines above. Prioritize English, next Tagalog. Be helpful, witty, and professional. Generate content using the specified format when requested.`;

     const personaSystemPrompts = {
        // Content Creation Roles
        "Content Writer": { name: "Maria Santos", profession: "Content Writer", display: "Content Writer" },
        "Copywriter": { name: "Carlos Reyes", profession: "Copywriter", display: "Copywriter" },
        "Blogger": { name: "Bianca Mendoza", profession: "Blogger", display: "Blogger" },
        "Social Media Manager": { name: "Sofia Garcia", profession: "Social Media Manager", display: "Social Media Manager" },
        "Video Script Writer": { name: "Victor Lim", profession: "Video Script Writer", display: "Video Script Writer" },
        "SEO Specialist": { name: "Samuel Ortiz", profession: "SEO Specialist", display: "SEO Specialist" },
        "Email Marketer": { name: "Elena Cruz", profession: "Email Marketer", display: "Email Marketer" },
        "Podcast Producer": { name: "Paolo Dizon", profession: "Podcast Producer", display: "Podcast Producer" },
        
        // Creative Content Roles
        "Storyteller": { name: "Selena Torres", profession: "Storyteller", display: "Storyteller" },
        "Creative Writer": { name: "Cristina Villanueva", profession: "Creative Writer", display: "Creative Writer" },
        "Poet": { name: "Pedro Aquino", profession: "Poet", display: "Poet" },
        "Scriptwriter": { name: "Sandra Bautista", profession: "Scriptwriter", display: "Scriptwriter" },
        "Ghostwriter": { name: "Gabriel Tan", profession: "Ghostwriter", display: "Ghostwriter" },
        "Narrative Designer": { name: "Natalia Domingo", profession: "Narrative Designer", display: "Narrative Designer" },
        
        // Marketing Content Roles
        "Brand Strategist": { name: "Benjamin Santos", profession: "Brand Strategist", display: "Brand Strategist" },
        "Marketing Specialist": { name: "Marissa Fernandez", profession: "Marketing Specialist", display: "Marketing Specialist" },
        "PR Specialist": { name: "Patricia Reyes", profession: "PR Specialist", display: "PR Specialist" },
        "Ad Copywriter": { name: "Antonio Castillo", profession: "Ad Copywriter", display: "Ad Copywriter" },
        "Landing Page Specialist": { name: "Leila Pascual", profession: "Landing Page Specialist", display: "Landing Page Specialist" },
        "Conversion Copywriter": { name: "Camilo Ramos", profession: "Conversion Copywriter", display: "Conversion Copywriter" },
        
        // Technical Content Roles
        "Technical Writer": { name: "Teresa Gonzales", profession: "Technical Writer", display: "Technical Writer" },
        "Documentation Specialist": { name: "Danilo Ocampo", profession: "Documentation Specialist", display: "Documentation Specialist" },
        "UX Writer": { name: "Ursula Xavier", profession: "UX Writer", display: "UX Writer" },
        "Knowledge Base Writer": { name: "Karlo Bautista", profession: "Knowledge Base Writer", display: "Knowledge Base Writer" },
        "API Documentation Writer": { name: "Adrian Perez", profession: "API Documentation Writer", display: "API Documentation Writer" },
        
        // Educational Content Roles
        "Instructional Designer": { name: "Isabella Dizon", profession: "Instructional Designer", display: "Instructional Designer" },
        "Course Creator": { name: "Cesar Magsaysay", profession: "Course Creator", display: "Course Creator" },
        "Educational Content Writer": { name: "Eduardo Cruz", profession: "Educational Content Writer", display: "Educational Content Writer" },
        "Tutorial Writer": { name: "Trina Villanueva", profession: "Tutorial Writer", display: "Tutorial Writer" },
        "E-learning Specialist": { name: "Elisa Santiago", profession: "E-learning Specialist", display: "E-learning Specialist" },
        
        // Business Content Roles
        "Business Writer": { name: "Bernard Tan", profession: "Business Writer", display: "Business Writer" },
        "Grant Writer": { name: "Grace Lim", profession: "Grant Writer", display: "Grant Writer" },
        "Proposal Writer": { name: "Paulo Reyes", profession: "Proposal Writer", display: "Proposal Writer" },
        "White Paper Writer": { name: "Wilma Padilla", profession: "White Paper Writer", display: "White Paper Writer" },
        "Case Study Writer": { name: "Carla Santos", profession: "Case Study Writer", display: "Case Study Writer" },
        "Financial Writer": { name: "Fernando Aquino", profession: "Financial Writer", display: "Financial Writer" },
        
        // Specialized Content Roles
        "Health & Wellness Writer": { name: "Helena Mercado", profession: "Health & Wellness Writer", display: "Health & Wellness Writer" },
        "Travel Writer": { name: "Tomas Rivera", profession: "Travel Writer", display: "Travel Writer" },
        "Food Writer": { name: "Felicia Gomez", profession: "Food Writer", display: "Food Writer" },
        "Fashion Writer": { name: "Francesca Luna", profession: "Fashion Writer", display: "Fashion Writer" },
        "Technology Writer": { name: "Teodoro Valdez", profession: "Technology Writer", display: "Technology Writer" },
        "Gaming Content Creator": { name: "Gino Pascual", profession: "Gaming Content Creator", display: "Gaming Content Creator" },
        "Lifestyle Writer": { name: "Liza Mendoza", profession: "Lifestyle Writer", display: "Lifestyle Writer" },
        "Product Description Writer": { name: "Pia Domingo", profession: "Product Description Writer", display: "Product Description Writer" },
        
        // Content Strategy Roles
        "Content Strategist": { name: "Cynthia Reyes", profession: "Content Strategist", display: "Content Strategist" },
        "Content Planner": { name: "Cesar Pimentel", profession: "Content Planner", display: "Content Planner" },
        "Editorial Calendar Manager": { name: "Emilia Cortez", profession: "Editorial Calendar Manager", display: "Editorial Calendar Manager" },
        "Content Auditor": { name: "Andres Navarro", profession: "Content Auditor", display: "Content Auditor" },
        "Content Optimization Specialist": { name: "Olivia Santos", profession: "Content Optimization Specialist", display: "Content Optimization Specialist" },
     };
     let currentPersonaData = personaSystemPrompts[currentPersona];
     let systemPrompt = '';

     function getSystemPrompt() { /* ... Same as before ... */
        currentPersona = personaDropdown.value;
        // --- Safely handle potentially missing persona data ---
        currentPersonaData = personaSystemPrompts[currentPersona] || { name: "WeConnect Creator", profession: "Content Creator", display: "Content Creator" }; // Default fallback
        if (!personaSystemPrompts[currentPersona]) {
            console.warn(`Persona data for "${currentPersona}" not found. Using default.`);
        }
        // --- End safety handle ---
        systemPrompt = baseSystemPrompt
                         .replace(/{{PROFESSION}}/g, currentPersonaData.profession)
                         .replace(/{{NAME}}/g, currentPersonaData.name);
        headerTitle.textContent = `Chat with ${currentPersonaData.display}`;
        return systemPrompt;
     }

    // --- Utility Functions (VH, DB, Firestore) ---
    // (VH function removed as CSS handles height better now)
    function initDB() { /* ... */ return Promise.resolve(); }
    function saveConversation(convo) { /* ... */ return Promise.resolve(); }
    async function saveChatToFirestore(persona, user_chat, bot_response) {
         try {
            const collectionRef = dbFirestore.collection('weconnect_chat');
            // Safely access name using the fallback logic from getSystemPrompt if needed
            const personaData = personaSystemPrompts[persona] || { name: "WeConnect Creator (Default)" };
            await collectionRef.add({
              persona: persona,
              persona_name: personaData.name, // Use the potentially defaulted name
              uid: 'SYSTEM_USER_ID', // Replace with actual user ID if available
              created_at: firebase.firestore.Timestamp.now(),
              user: 'SYSTEM_USER_REF', // Replace with actual user ref if available
              user_chat: user_chat,
              bot_response: bot_response,
              user_who_chat: 'SYSTEM_USER_REF' // Replace with actual user ref if available
            });
            // console.log('Chat saved to Firestore'); // Keep console log minimal
          } catch (error) { console.error('Error saving chat to Firestore:', error); }
    }

    // --- Chat Interface ---
    const chat = document.getElementById("chat");
    const chatContainer = document.getElementById("chat-container");
    const messageInput = document.getElementById("message");
    const submitButton = document.getElementById("submit");
    const micButton = document.getElementById("mic-button");

    // --- MODIFIED addMessage function ---
    function addMessage(textPart, isUser = true, isDocument = false, docHtml = '', docMarkdown = '') {
        const messageEl = document.createElement("li");
        messageEl.classList.add("message", isUser ? "user-message" : "bot-message");

        const contentDiv = document.createElement("div");
        contentDiv.classList.add("message-content");

        let docContainer = null; // Keep track of the document container

        if (isUser) {
            // User messages are plain text
            contentDiv.textContent = textPart;
        } else {
            // --- Bot Message Handling ---

            // 1. Add regular text part (if any)
            if (textPart && textPart.trim() !== '') {
                const textDiv = document.createElement('div');
                // Use 'marked' to render potential basic markdown in the non-document text part
                textDiv.innerHTML = marked.parse(textPart.trim());
                contentDiv.appendChild(textDiv);
            }

            // 2. Add document part (if any)
            if (isDocument) {
                // Create the document container
                docContainer = document.createElement("div");
                docContainer.classList.add("document-content");
                docContainer.innerHTML = docHtml; // Render the parsed HTML from Markdown
                contentDiv.appendChild(docContainer); // Append the document container

                // Create Actions container
                const actionsDiv = document.createElement("div");
                actionsDiv.classList.add("document-actions");

                // Create Edit Button
                const editButton = document.createElement("button");
                editButton.textContent = "Edit";
                editButton.classList.add("doc-action-button", "edit-button");
                editButton.type = "button"; // Prevent form submission
                editButton.addEventListener('click', () => {
                    if (docContainer.isContentEditable) {
                        // Stop editing
                        docContainer.contentEditable = false;
                        docContainer.classList.remove('editing');
                        editButton.textContent = "Edit";
                        // Optional: Add logic here if you want to *do* something with the edited HTML
                        // console.log("Edited HTML:", docContainer.innerHTML);
                    } else {
                        // Start editing
                        docContainer.contentEditable = true;
                        docContainer.classList.add('editing');
                        editButton.textContent = "Done";
                        docContainer.focus(); // Focus the editor
                    }
                });

                // Create Copy Button
                const copyButton = document.createElement("button");
                copyButton.textContent = "Copy";
                copyButton.classList.add("doc-action-button", "copy-button");
                copyButton.type = "button"; // Prevent form submission
                copyButton.addEventListener('click', async () => {
                    try {
                        // Copy the ORIGINAL MARKDOWN content
                        await navigator.clipboard.writeText(docMarkdown);
                        copyButton.textContent = "Copied!";
                        copyButton.classList.add('copied');
                        setTimeout(() => {
                            copyButton.textContent = "Copy";
                            copyButton.classList.remove('copied');
                        }, 1500); // Revert after 1.5 seconds
                    } catch (err) {
                        console.error('Failed to copy document markdown: ', err);
                        copyButton.textContent = "Error";
                         setTimeout(() => { copyButton.textContent = "Copy"; }, 1500);
                    }
                });

                actionsDiv.appendChild(editButton);
                actionsDiv.appendChild(copyButton);
                contentDiv.appendChild(actionsDiv); // Add actions below document

                 // Adjust top padding if ONLY document+actions are present
                 if (!textPart || textPart.trim() === '') {
                    contentDiv.style.paddingTop = '5px'; // Reduce top padding
                    contentDiv.style.paddingBottom = '0px'; // Remove bottom padding as actions has its own
                 }

            } else if (!textPart || textPart.trim() === '') {
                 // Handle case where bot response is empty or only whitespace and not a doc
                 contentDiv.innerHTML = "<i>(I don't have a response for that at the moment.)</i>"; // More user-friendly empty message
            }
        }

        messageEl.appendChild(contentDiv);
        chat.appendChild(messageEl);

        // Scroll chat container to the bottom smoothly
        requestAnimationFrame(() => {
             chatContainer.scrollTo({ top: chatContainer.scrollHeight, behavior: 'smooth' });
        });

        return messageEl;
    }


    function showLoadingIndicator() { /* ... Same as before ... */
        const messageEl = document.createElement("li");
        messageEl.classList.add("message", "bot-message", "loading");
        messageEl.innerHTML = 'Thinking <div class="loading-dots"><span></span><span></span><span></span></div>';
        chat.appendChild(messageEl);
        requestAnimationFrame(() => { chatContainer.scrollTop = chatContainer.scrollHeight; });
        return messageEl;
     }

    // --- Speech Recognition (Deepgram) ---
    // (Keep the setup, start, stop, transcribe functions as before, including API key warning)
    let mediaRecorder;
    let audioChunks = [];
    let isRecording = false;
    const recordingStatus = document.getElementById('recording-status');
    const micButtonIcon = micButton.querySelector('.material-icons');

    async function setupAudioRecording() { /* ... same ... */
         try {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                 throw new Error('Media Devices API not supported.');
            }
            const stream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: true, noiseSuppression: true } });
            mediaRecorder = new MediaRecorder(stream);
            mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) audioChunks.push(event.data);
            };
            mediaRecorder.onstop = async () => {
                micButton.disabled = true; micButtonIcon.textContent = 'hourglass_top';
                recordingStatus.classList.remove('visible');
                if (audioChunks.length === 0) {
                     console.warn("No audio data recorded.");
                     micButton.classList.remove('recording'); micButton.disabled = false;
                     micButtonIcon.textContent = 'mic';
                     return; // Exit if no audio was captured
                }
                const audioBlob = new Blob(audioChunks, { type: mediaRecorder.mimeType || 'audio/webm' }); // Use mimeType if available
                const transcription = await transcribeAudio(audioBlob);
                if (transcription) { messageInput.value = transcription; messageInput.focus(); }
                audioChunks = []; isRecording = false;
                micButton.classList.remove('recording'); micButton.disabled = false;
                micButtonIcon.textContent = 'mic';
                // Stop all tracks on the stream to release the mic
                stream.getTracks().forEach(track => track.stop());
            };
            // Handle potential errors during recording
            mediaRecorder.onerror = (event) => {
                 console.error("MediaRecorder error:", event.error);
                 stopRecording(); // Try to clean up
                 alert("Error occurred while recording."); 
                 micButton.classList.remove('recording'); micButton.disabled = false;
                 micButtonIcon.textContent = 'mic';
                 isRecording = false;
                 audioChunks = [];
                 stream.getTracks().forEach(track => track.stop());
             };
            return true;
        } catch (error) {
            console.error("Error accessing microphone:", error);
            alert(`Cannot access microphone: ${error.message}. Please check browser permissions.`);
            micButtonIcon.textContent = 'mic_off'; micButton.disabled = true; // Disable mic button if setup fails
            return false;
        }
    }
    function startRecording() { /* ... same ... */
        if (!mediaRecorder || mediaRecorder.state === "inactive") { // Check state
            setupAudioRecording().then(success => { if (success) beginRecording(); });
        } else if (mediaRecorder.state === "paused") { // If paused, resume
            mediaRecorder.resume();
            isRecording = true;
            micButton.classList.add('recording'); recordingStatus.classList.add('visible');
            micButtonIcon.textContent = 'stop';
        } else {
             console.warn("MediaRecorder is already recording or in an unexpected state:", mediaRecorder.state);
        }
    }
    function beginRecording() { /* ... same ... */
        if (mediaRecorder && mediaRecorder.state === "inactive") {
            audioChunks = [];
            mediaRecorder.start();
            isRecording = true;
            micButton.classList.add('recording'); recordingStatus.classList.add('visible');
            micButtonIcon.textContent = 'stop';
        } else {
             console.error("Cannot begin recording, MediaRecorder not ready or already active.");
             // Optionally try to reset or alert user
        }
    }
    function stopRecording() { /* ... same ... */
         if (mediaRecorder && isRecording) { // Check isRecording flag too
             mediaRecorder.stop(); // This triggers the onstop event
             // UI changes are handled in onstop
             isRecording = false; // Set recording flag immediately
         } else {
            // Clean up UI just in case state is inconsistent
            micButton.classList.remove('recording');
            recordingStatus.classList.remove('visible');
            micButtonIcon.textContent = 'mic';
            micButton.disabled = false;
         }
    }
    async function transcribeAudio(audioBlob) { /* ... same ... */
        if (!DEEPGRAM_API_KEY || DEEPGRAM_API_KEY === "YOUR_DEEPGRAM_API_KEY") { // Use constant correctly
             alert("Deepgram API Key is not configured."); 
             return "";
        }
        messageInput.value = "Transcribing..."; messageInput.disabled = true;
        try {
            // Use fetch API with appropriate headers for Deepgram
            const response = await fetch('https://api.deepgram.com/v1/listen?language=en&model=nova-2', { // Changed to English
                method: 'POST',
                headers: {
                    'Authorization': `Token ${DEEPGRAM_API_KEY}`, // Use constant correctly
                    'Content-Type': audioBlob.type || 'audio/webm' // Use blob's type
                },
                body: audioBlob
            });

            if (!response.ok) {
                const errorBody = await response.text();
                throw new Error(`Deepgram API Error: ${response.status} ${response.statusText} - ${errorBody}`);
            }

            const data = await response.json();

            // Extract transcription using optional chaining for safety
            const transcript = data?.results?.channels?.[0]?.alternatives?.[0]?.transcript;

            if (transcript) {
                return transcript;
            } else {
                console.warn("Deepgram: No transcription result found in response.", data);
                return ""; // Return empty string if no transcript
            }
        } catch (error) {
            console.error("Error transcribing audio:", error);
            alert(`Transcription failed: ${error.message}. Please try again or type your message.`);
            return ""; // Return empty string on error
        } finally {
            // Always re-enable input regardless of success/failure
            messageInput.value = ""; // Clear "Transcribing..."
            messageInput.disabled = false;
            micButtonIcon.textContent = 'mic'; // Ensure mic icon is reset
            micButton.disabled = false;
        }
    }


    // --- Gemini Text Generation ---
    async function generateText(userMessage) { /* ... Same function as before ... */
        if (!API_KEY || API_KEY === "YOUR_GEMINI_API_KEY") { // Use constant correctly
             throw new Error("Gemini API Key is not configured.");
        }
        try {
            const currentSystemPrompt = getSystemPrompt();
            const generationUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${API_KEY}`; // Use constant correctly
            const body = {
            contents: [ { role: "user", parts: [{ text: currentSystemPrompt + "\n\n---\n\nUser Question:\n" + userMessage }] } ],
            generationConfig: { temperature: 0.8, topK: 40, topP: 0.95, maxOutputTokens: 8192, responseMimeType: "text/plain" },
            safetySettings: [ /* ... safety settings ... */
                { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
             ]
            };
            const response = await fetch(generationUrl, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(body) });
            if (!response.ok) { /* ... error handling ... */
                const errorBody = await response.text(); console.error("API Error Response:", errorBody);
                throw new Error(`Text generation failed: ${response.status} ${response.statusText}`);
            }
            const result = await response.json();
            // Enhanced safety/empty check
            const candidate = result?.candidates?.[0];
            const textContent = candidate?.content?.parts?.[0]?.text;
            const finishReason = candidate?.finishReason;
            const safetyRatings = candidate?.safetyRatings;

            if (finishReason === "STOP" && textContent) {
                 return result; // Valid response
            } else if (finishReason === "SAFETY") {
                 console.warn("API Result blocked due to safety:", result);
                 const blockedCategories = safetyRatings?.filter(r => r.blocked).map(r => r.category).join(', ') || 'Unknown';
                 throw new Error(`Content blocked by API safety filters: ${blockedCategories}`);
            } else if (finishReason === "MAX_TOKENS") {
                console.warn("API Result truncated due to max tokens:", result);
                return result; // Return truncated result
            } else {
                 console.warn("API Result issue (Invalid Response or other reason):", result);
                 throw new Error(`Received invalid or empty response from AI. Reason: ${finishReason || 'Unknown'}`);
            }
        } catch (error) { console.error("API Call Error:", error); throw error; } // Re-throw error
     }


    // --- Initialize and Setup Form ---
    document.addEventListener("DOMContentLoaded", async () => {
        try {
            await initDB();
            getSystemPrompt(); // Set initial persona and title

            // Check if API keys are placeholder values
             if (!firebaseConfig.apiKey || firebaseConfig.apiKey.startsWith("YOUR_")) {
                  console.warn("Firebase is not configured. Database saving will fail.");
                  alert("Warning: Firebase is not properly configured.");
             }
             if (!API_KEY || API_KEY.startsWith("YOUR_")) { // Use constant correctly
                 console.warn("Gemini API Key is not configured. Chat functionality will fail.");
                 alert("Warning: Gemini API Key is not configured.");
             }
             if (!DEEPGRAM_API_KEY || DEEPGRAM_API_KEY.startsWith("YOUR_")) { // Use constant correctly
                  console.warn("Deepgram API Key is not configured. Voice input will fail.");
                  // Don't alert for this one unless mic is clicked, maybe disable mic button?
                  micButton.disabled = true;
                  micButtonIcon.textContent = 'mic_off';
                  micButton.title = "Voice input not available (API key required)"; // Add tooltip
             } else {
                // Attempt to setup audio recording early if key exists
                // This allows requesting permission sooner.
                 setupAudioRecording();
             }


            setTimeout(() => {
                // Use the new addMessage structure for the initial greeting
                 // Use the currentPersonaData that was set by getSystemPrompt()
                addMessage(`Hello! I'm ${currentPersonaData.name}, your ${currentPersonaData.profession}. How can I help you with your content creation needs today?`, false, false, '', '');
            }, 500);
        } catch (error) { console.error("Initialization Error:", error); }

        const form = document.getElementById("form");
        const personaDropdownElement = document.getElementById('persona-dropdown');

        personaDropdownElement.addEventListener('change', () => {
            getSystemPrompt(); // Updates currentPersonaData
            // Use the new addMessage structure and the updated currentPersonaData
            addMessage(`Great! You're now chatting with ${currentPersonaData.name}, your ${currentPersonaData.profession}. How can I assist with your content needs?`, false, false, '', '');
            console.log(`Persona changed to: ${currentPersona}`);
        });

        micButton.addEventListener("click", () => {
            if (micButton.disabled) return; // Don't do anything if disabled
            if (isRecording) {
                stopRecording();
            } else {
                // Re-check permission or setup if needed, then start
                setupAudioRecording().then(success => {
                     if (success) startRecording();
                });
            }
        });
        // Add touch feedback (optional but good for mobile)
        const addTouchFeedback = (button) => {
            button.addEventListener("touchstart", () => button.style.opacity = "0.7", { passive: true });
            button.addEventListener("touchend", () => button.style.opacity = "1", { passive: true });
            button.addEventListener("touchcancel", () => button.style.opacity = "1", { passive: true });
        };
        addTouchFeedback(micButton);
        addTouchFeedback(submitButton);

        form.addEventListener("submit", async (event) => {
            event.preventDefault();
            const userText = messageInput.value.trim();
            if (!userText) return;

            const selectedPersonaValue = personaDropdown.value; // Store before clearing input
            // Use the new addMessage structure for user message
            addMessage(userText, true, false, '', '');
            messageInput.value = "";

            messageInput.disabled = true; submitButton.disabled = true; micButton.disabled = true;
            const loadingIndicator = showLoadingIndicator();
            let botResponseTextForLogging = "Error occurred."; // For logging

            try {
                const generationResult = await generateText(userText);
                // Use optional chaining for safer access
                const rawBotResponse = generationResult?.candidates?.[0]?.content?.parts?.[0]?.text?.trim() ?? ''; // Default to empty string

                const docStartMarker = '%%%DOCUMENT_START%%%';
                const docEndMarker = '%%%DOCUMENT_END%%%';
                const startIdx = rawBotResponse.indexOf(docStartMarker);
                const endIdx = rawBotResponse.indexOf(docEndMarker);

                let textPart = rawBotResponse;
                let docMarkdown = '';
                let docHtml = ''; // Store parsed HTML here
                let isDoc = false;

                if (startIdx !== -1 && endIdx !== -1 && endIdx > startIdx) {
                    isDoc = true;
                    const textBefore = rawBotResponse.substring(0, startIdx).trim();
                    // Extract RAW markdown
                    docMarkdown = rawBotResponse.substring(startIdx + docStartMarker.length, endIdx).trim();
                    const textAfter = rawBotResponse.substring(endIdx + docEndMarker.length).trim();

                    textPart = (textBefore + " " + textAfter).trim(); // Combine surrounding text

                    // Parse markdown HERE before passing to addMessage
                    // Use marked options if needed (e.g., { breaks: true } for line breaks)
                    docHtml = marked.parse(docMarkdown || ''); // Parse the raw markdown

                    // Prepare text for logging (includes markdown structure)
                    botResponseTextForLogging = textPart + (textPart ? "\n\n" : "") + docStartMarker + "\n" + docMarkdown + "\n" + docEndMarker;

                } else {
                    // No document found, the whole response is the text part
                    textPart = rawBotResponse; // Already trimmed
                    botResponseTextForLogging = textPart;
                    // No need to parse textPart with marked here, addMessage will do it
                }

                loadingIndicator.remove(); // Remove *before* adding final message

                // Call addMessage with separated parts
                addMessage(textPart, false, isDoc, docHtml, docMarkdown);


                await saveConversation({ userMessage: userText, botResponse: botResponseTextForLogging, timestamp: new Date().toISOString() });
                await saveChatToFirestore(selectedPersonaValue, userText, botResponseTextForLogging);

            } catch (error) {
                console.error("Error during generation/processing:", error);
                if (loadingIndicator) loadingIndicator.remove(); // Ensure loading is removed on error
                const userFriendlyErrorMessage = error.message.includes("API Key is not configured")
                    ? "Sorry, it looks like the system isn't properly set up (API Key missing)."
                    : error.message.includes("safety filters")
                    ? "I'm sorry, I can't generate a response to that due to safety guidelines. Please try rephrasing your request."
                    : "Sorry, we're experiencing a system issue. Please try again later.";

                // Use addMessage for error message
                addMessage(userFriendlyErrorMessage, false, false, '', '');
                botResponseTextForLogging = `[ERROR: ${error.message}]`;
                // Log error to Firestore as well
                await saveChatToFirestore(selectedPersonaValue, userText, botResponseTextForLogging);

            } finally {
                messageInput.disabled = false;
                submitButton.disabled = false;
                // Only enable mic if it wasn't disabled due to config error
                if (!(DEEPGRAM_API_KEY || "").startsWith("YOUR_")) { // Use constant correctly
                     micButton.disabled = false;
                     // Ensure mic icon is correct if recording stopped unexpectedly
                     if (!isRecording) micButtonIcon.textContent = 'mic';
                }
                messageInput.focus();
            }
        });
    });

  </script>

</body>
</html><script>
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('/service-worker.js')
        .then(registration => {
          console.log('Service Worker registered with scope:', registration.scope);
        })
        .catch(error => {
          console.error('Service worker registration failed:', error);
        });
    }
  <\/script>
