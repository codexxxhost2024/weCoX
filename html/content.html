<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>WeConnect - Social</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <!-- PWA Meta Tags -->
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="WeConnect - Social Feed">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="default">
  <meta name="apple-mobile-web-app-title" content="WeConnect">
  <!-- PWA Manifest & Apple Touch Icons -->
  <link rel="manifest" href="/manifest.json">
  <link rel="apple-touch-icon" href="/icons/icon-192x192.png">
  <!-- Fonts & Icons -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;600&family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Material+Icons" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Material+Icons+Outlined" rel="stylesheet">
  <style>
    /* Global Styles & Variables */
    :root {
      --WeConnect-blue: #696ffa;
      --text-dark: #1A1A1A;
      --text-secondary: #65676b;
      --facebook-blue: #1877F2;
      --card-background: #ffffff;
      --body-background: #f0f2f5;
      --separator-color: #e0e0e0;
      --input-background: #f0f2f5;
      --icon-color-inactive: var(--text-secondary);
      --icon-color-active: var(--facebook-blue);
      --like-color: #e0245e;
      --header-height: 64px;
      --border-radius-soft: 8px;
      --border-radius-pill: 9999px;
      --transition-speed: 0.2s;
    }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html { scroll-behavior: smooth; }
    body {
      font-family: 'Open Sans', sans-serif;
      background-color: var(--body-background);
      color: var(--text-dark);
      -webkit-tap-highlight-color: transparent;
      overflow-x: hidden;
      max-width: 24rem; /* Approx 384px */
      margin: 0 auto; /* Center the content */
      position: relative;
      padding-bottom: 0;
    }
    h1, h2, h3, h4, h5, h6, .heading { font-family: 'Roboto', sans-serif; }

    /* Sticky Header */
    .sticky-header {
      background-color: var(--card-background);
      padding: 0 0.75rem; /* Adjusted padding */
      display: flex;
      align-items: center;
      gap: 0.5rem; /* Gap between icons and search */
      border-bottom: 1px solid var(--separator-color);
      position: fixed;
      top: 0;
      left: auto;
      right: auto;
      width: 100%;
      max-width: 24rem;
      z-index: 50;
      height: var(--header-height);
      box-shadow: 0 1px 3px rgba(0,0,0,0.05);
    }
    .sticky-header .header-icon-link {
      text-decoration: none;
      display: flex;
      align-items: center;
      color: var(--icon-color-inactive);
      flex-shrink: 0; /* Prevent icons from shrinking */
    }
    .sticky-header .header-icon {
      color: var(--icon-color-inactive);
      font-size: 1.7rem; /* Adjusted icon size */
      cursor: pointer;
      padding: 0.4rem;
      border-radius: 50%;
      transition: color var(--transition-speed) ease, background-color var(--transition-speed) ease;
    }
    .sticky-header .header-icon-link:hover .header-icon,
    .sticky-header .header-icon:hover {
      color: var(--text-dark);
      background-color: #f0f0f0;
    }
    .header-search-container {
      flex-grow: 1;
      display: flex;
      align-items: center;
      background-color: var(--input-background);
      border-radius: var(--border-radius-pill);
      padding: 0.4rem 0.8rem; /* Increased padding for better feel */
      margin-left: 0.5rem; /* Space before search bar */
      height: 38px; /* Fixed height for search bar */
    }
    .header-search-input {
      flex-grow: 1;
      border: none;
      outline: none;
      background-color: transparent;
      font-size: 0.9rem;
      margin-left: 0.5rem;
      color: var(--text-dark);
      font-family: 'Open Sans', sans-serif;
    }
    .header-search-input::placeholder {
      color: var(--text-secondary);
    }
    .search-icon-inside {
      color: var(--text-secondary);
      font-size: 1.3rem; /* Slightly larger search icon */
    }
    .sticky-header .header-back-button {
        margin-right: 0.25rem; /* Small space after back button */
    }


    /* Create Post Form (Inline Component) */
    .create-post-form-container {
      background-color: var(--card-background);
      padding: 1rem;
      border-bottom: 6px solid var(--body-background);
    }
    .create-post-form-container .form-row {
      display: flex;
      align-items: flex-start;
      gap: 0.75rem;
      margin-bottom: 0.75rem;
    }
    .create-post-form-container .post-avatar, .post-avatar {
      width: 40px;
      height: 40px;
      border-radius: var(--border-radius-pill);
      overflow: hidden;
      flex-shrink: 0;
      background-color: #e5e7eb;
    }
    .create-post-form-container .post-avatar img, .post-avatar img {
      width: 100%; height: 100%; object-fit: cover;
    }
    .create-post-form-container .form-post-textarea {
      flex-grow: 1;
      min-height: 60px;
      padding: 0.7rem 0.9rem;
      border: 1px solid #ddd;
      border-radius: var(--border-radius-soft);
      font-size: 0.95rem;
      line-height: 1.4;
      resize: vertical;
      background-color: var(--input-background);
      font-family: 'Open Sans', sans-serif;
    }
    .create-post-form-container .form-post-textarea::placeholder { color: var(--text-secondary); }
    .create-post-form-container .form-post-textarea:focus {
      border-color: var(--facebook-blue); outline: none;
      background-color: #fff;
    }
    .create-post-form-container .form-actions {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 0.5rem;
    }
    .create-post-form-container .form-media-label {
      cursor: pointer;
      color: var(--text-secondary);
      padding: 0.5rem 0.75rem;
      border-radius: var(--border-radius-soft);
      display: flex;
      align-items: center;
      gap: 0.4rem;
      transition: background-color var(--transition-speed) ease;
      font-size: 0.85rem;
    }
    .create-post-form-container .form-media-label:hover { background-color: #e9ebee; }
    .create-post-form-container .form-media-label .material-icons-outlined {
      color: #45bd62; font-size: 1.4rem;
    }
    .create-post-form-container .form-submit-button {
      background-color: var(--facebook-blue); color: white;
      border: none; border-radius: var(--border-radius-soft);
      padding: 0.6rem 1.2rem; font-size: 0.9rem; font-weight: 600;
      cursor: pointer; transition: background-color var(--transition-speed) ease;
      display: flex; align-items: center; justify-content: center;
    }
    .create-post-form-container .form-submit-button:hover { background-color: #166fe5; }
    .create-post-form-container .form-submit-button:disabled {
      background-color: #a0c3f0; cursor: not-allowed;
    }
    .upload-spinner-inline {
        width: 16px; height: 16px; border-radius: 50%;
        border: 2px solid rgba(255, 255, 255, 0.5);
        border-top-color: #fff;
        animation: spin 0.8s linear infinite;
        display: inline-block; margin-left: 8px; vertical-align: middle;
    }
    #mediaPreviewContainer {
        margin-top: 0.75rem;
        padding: 0.5rem;
        background-color: var(--input-background);
        border-radius: var(--border-radius-soft);
        border: 1px dashed var(--separator-color);
    }
    #mediaPreviewContainer img, #mediaPreviewContainer video {
        max-width: 100%;
        max-height: 200px; /* Adjusted preview height for consistency */
        display: block;
        margin: 0 auto;
        border-radius: var(--border-radius-soft);
    }
    #mediaPreviewContainer canvas { /* For beautified image preview */
        max-width: 100%;
        max-height: 200px;
        display: block;
        margin: 0 auto;
        border-radius: var(--border-radius-soft);
    }

    .form-extra-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-top: 0.75rem;
      border-top: 1px solid var(--separator-color);
      padding-top: 0.75rem;
    }
    .form-tool-button {
      background-color: #e4e6eb; color: var(--text-dark);
      border: none; border-radius: var(--border-radius-soft);
      padding: 0.5rem 0.8rem; font-size: 0.8rem; font-weight: 600;
      cursor: pointer; transition: background-color var(--transition-speed) ease;
      display: flex; align-items: center; gap: 0.4rem;
      flex-grow: 1; /* Allow buttons to grow and fill space */
      justify-content: center;
    }
    .form-tool-button:hover { background-color: #d8dadf; }
    .form-tool-button .material-icons-outlined { font-size: 1.1rem; }
    .form-tool-button.small { padding: 0.4rem 0.6rem; font-size: 0.75rem; flex-grow: 0;}


    /* Media Enhancement Controls Styling */
    #mediaEnhancementControls {
      display: none; margin-top: 0.75rem; padding: 0.75rem;
      background-color: #f7f7f7; border-radius: var(--border-radius-soft);
      border: 1px solid var(--separator-color);
    }
    #mediaEnhancementControls h4, #mediaEnhancementControls h5 { margin-bottom: 0.5rem; font-size: 0.9rem; }
    #mediaEnhancementControls label { font-size: 0.85rem; display: block; margin-bottom: 0.25rem; }
    #mediaEnhancementControls input[type="range"] { width: 100%; margin-bottom: 0.5rem; }
    #mediaEnhancementControls .form-tool-button { margin-top: 0.5rem; margin-right: 0.5rem;}
    #videoRecordPreview.filtered {
      filter: contrast(1.1) brightness(1.05) saturate(1.2);
    }
    #videoTrimPreviewContainer video {
        width: 100%; max-height: 150px; border-radius: var(--border-radius-soft); background-color: #333;
    }


    /* Main Content Area */
    main {
      padding-top: var(--header-height);
      width: 100%;
    }

    /* Stories & Reels */
    .stories-reels-tabs {
      background-color: var(--card-background); display: flex;
      border-bottom: 1px solid var(--separator-color);
    }
    .tab-button {
      flex: 1; padding: 0.9rem 0; text-align: center;
      font-weight: 600; color: var(--icon-color-inactive);
      cursor: pointer; position: relative;
      border-bottom: 3px solid transparent;
      transition: color var(--transition-speed) ease, border-bottom-color var(--transition-speed) ease;
    }
    .tab-button.active {
      color: var(--icon-color-active);
      border-bottom-color: var(--icon-color-active);
    }
    .stories-container {
      background-color: var(--card-background); padding: 0.75rem 0.5rem;
      display: flex; gap: 0.5rem; overflow-x: auto;
      scrollbar-width: none; -ms-overflow-style: none;
      border-bottom: 6px solid var(--body-background);
    }
    .stories-container::-webkit-scrollbar { display: none; }
    .story-card {
      width: 90px; height: 160px; flex-shrink: 0;
      border-radius: var(--border-radius-soft);
      background-color: #e4e6eb; overflow: hidden;
      cursor: pointer; position: relative;
      box-shadow: 0 1px 2px rgba(0,0,0,0.1);
      border: 1px solid rgba(0, 0, 0, 0.05);
      transition: transform var(--transition-speed) ease-in-out;
    }
    .story-card:hover { transform: scale(1.03); }
    .story-card .story-avatar {
      position: absolute; top: 8px; left: 8px;
      width: 32px; height: 32px; border-radius: 50%;
      border: 3px solid var(--facebook-blue);
      overflow: hidden; z-index: 3;
    }
    .story-card .story-avatar img { width: 100%; height: 100%; object-fit: cover; }
    .story-card .story-author-name {
      position: absolute; bottom: 8px; left: 8px; right: 8px;
      color: white; font-size: 0.75rem; font-weight: 600;
      text-shadow: 0 1px 3px rgba(0,0,0,0.7); z-index: 3;
      text-align: center; white-space: nowrap;
      overflow: hidden; text-overflow: ellipsis;
    }
    .story-card::after {
      content: ''; position: absolute; bottom: 0; left: 0; right: 0;
      height: 50%; background: linear-gradient(to top, rgba(0,0,0,0.6), transparent);
      z-index: 2; pointer-events: none;
    }
    .story-card img.story-bg {
      width: 100%; height: 100%; object-fit: cover;
      display: block; transition: transform 0.3s ease-in-out;
    }
    .story-card:hover img.story-bg { transform: scale(1.05); }
    .create-story-card {
      background-color: var(--card-background);
      display: flex; flex-direction: column;
    }
    .create-story-card img.user-avatar {
      width: 100%; height: 100px; object-fit: cover;
      border-bottom: 1px solid var(--separator-color);
    }
    .create-story-content {
      flex-grow: 1; position: relative; display: flex;
      justify-content: center; background-color: var(--card-background);
    }
    .create-story-icon-wrapper {
      position: absolute; top: -18px; left: 50%; transform: translateX(-50%);
      width: 36px; height: 36px; background-color: var(--facebook-blue);
      border-radius: 50%; border: 4px solid var(--card-background);
      display: flex; align-items: center; justify-content: center; z-index: 2;
    }
    .create-story-icon { color: white; font-size: 22px; font-weight: bold; line-height: 1; }
    .create-story-label {
      font-size: 0.75rem; font-weight: 600; color: var(--text-secondary);
      text-align: center; padding-top: 22px; padding-bottom: 5px;
    }

    /* Post Feed */
    .post-list {
      display: flex; flex-direction: column; gap: 0; padding: 0;
    }
    .post-card {
      background-color: var(--card-background); overflow: hidden;
      display: flex; flex-direction: column;
      border-bottom: 6px solid var(--body-background);
      margin-bottom: 0; position: relative;
      box-shadow: 0 1px 2px rgba(0,0,0,0.05);
    }
    .post-card.hidden-by-search { display: none !important; } /* For search filter */
    .post-list > .empty-state { /* Styling for search empty state if it's inside post-list */
        margin-top: 1rem;
    }

    .post-header {
      display: flex; align-items: center; gap: 0.6rem;
      padding: 0.75rem 1rem;
    }
    .post-info {
      display: flex; flex-direction: column;
      font-size: 0.85rem; line-height: 1.3;
    }
    .post-author { font-weight: 600; color: #050505; }
    .post-time { font-size: 0.75rem; color: var(--icon-color-inactive); }
    .post-content {
      padding: 0.25rem 1rem 0.75rem 1rem; font-size: 0.9rem;
      line-height: 1.45; color: #1c1e21; word-wrap: break-word;
    }
    .post-media {
      max-height: 500px; overflow: hidden; background-color: #000;
      display: flex; justify-content: center; align-items: center;
    }
    .post-media img, .post-media video {
      width: 100%; height: auto; max-height: 500px;
      object-fit: contain; display: block;
    }
    /* Image Glow Effect */
    .post-media img.image-glow {
      box-shadow: 0 0 10px 2px rgba(var(--WeConnect-blue-rgb, 105, 111, 250), 0.3), /* Main color glow */
                  0 0 15px 4px rgba(255, 255, 255, 0.2); /* Softer white outer glow */
      transition: box-shadow 0.3s ease-in-out;
      border-radius: 2px; /* Slight rounding for the glow to look softer on edges */
    }
    .post-media img.image-glow:hover {
      box-shadow: 0 0 16px 4px rgba(var(--WeConnect-blue-rgb, 105, 111, 250), 0.5),
                  0 0 25px 7px rgba(255, 255, 255, 0.3);
    }


    .post-stats {
      display: flex; justify-content: space-between; align-items: center;
      padding: 0.6rem 1rem; font-size: 0.8rem; color: var(--icon-color-inactive);
      border-bottom: 1px solid var(--separator-color);
    }
    .post-stats .likes-count, .post-stats .comments-count {
      display: flex; align-items: center; gap: 0.25rem;
    }
    .post-stats .likes-count .material-icons {
        font-size: 0.9rem; color: var(--icon-color-inactive); margin-right: 2px;
    }
    .post-stats .likes-count .like-icon-filled { color: var(--facebook-blue); }
    .post-actions {
      display: flex; justify-content: space-around;
      padding: 0.1rem 0; border-bottom: 1px solid var(--separator-color);
    }
    .action-button {
      flex: 1; display: flex; align-items: center; justify-content: center;
      gap: 0.4rem; padding: 0.6rem 0; cursor: pointer;
      border-radius: var(--border-radius-soft);
      transition: background-color var(--transition-speed) ease, color var(--transition-speed) ease;
      font-size: 0.85rem; font-weight: 600; color: var(--icon-color-inactive);
      background: none; border: none;
    }
    .action-button:hover { background-color: var(--input-background); }
    .action-button .material-icons, .action-button .material-icons-outlined { font-size: 1.25rem; }
    .action-button.liked .material-icons { color: var(--like-color); }
    .action-button.liked { color: var(--like-color); }

    /* Comments Section */
    .comments-section {
      padding: 0.5rem 1rem; font-size: 0.85rem;
      transition: max-height 0.3s ease-out, opacity 0.3s ease-out, padding 0.3s ease-out;
      max-height: 0; opacity: 0; overflow: hidden;
      padding-top: 0; padding-bottom: 0;
    }
    .comments-section.visible { opacity: 1; }
    .comment { display: flex; gap: 0.5rem; margin-bottom: 0.5rem; }
    .comment-avatar {
      width: 32px; height: 32px; border-radius: 50%;
      overflow: hidden; flex-shrink: 0;
    }
    .comment-avatar img { width: 100%; height: 100%; object-fit: cover; }
    .comment-content {
      background-color: var(--input-background); padding: 0.5rem 0.75rem;
      border-radius: 15px; flex-grow: 1;
    }
    .comment-author {
      font-weight: 600; color: #050505;
      font-size: 0.8rem; margin-bottom: 0.1rem;
    }
    .comment-text { color: #1c1e21; word-wrap: break-word; line-height: 1.35; }
    .comment-time { font-size: 0.7rem; color: var(--icon-color-inactive); margin-top: 0.2rem; }
    .comment-input-area {
      display: flex; align-items: center; gap: 0.5rem;
      padding: 0.5rem 1rem 0.75rem 1rem;
    }
    .comment-input-area .post-avatar { width: 32px; height: 32px; }
    .comment-input {
      flex-grow: 1; background-color: var(--input-background);
      border: 1px solid #ddd; border-radius: var(--border-radius-pill);
      padding: 0.5rem 1rem; font-size: 0.9rem; outline: none;
      transition: border-color var(--transition-speed) ease;
    }
    .comment-input:focus { border-color: var(--facebook-blue); }
    .comment-submit-btn {
      background: none; border: none; cursor: pointer;
      color: var(--facebook-blue); font-size: 1.5rem;
      padding: 0; line-height: 1;
      transition: color var(--transition-speed) ease;
    }
    .comment-submit-btn.disabled { color: var(--icon-color-inactive); cursor: default; }

    /* Loading overlay */
    .loading-overlay {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background-color: rgba(255, 255, 255, 0.8);
      display: flex; justify-content: center; align-items: center;
      z-index: 1000; opacity: 0; visibility: hidden;
      transition: opacity 0.3s ease, visibility 0.3s ease;
    }
    .loading-overlay.active { opacity: 1; visibility: visible; }
    .loading-spinner {
      width: 40px; height: 40px; border-radius: 50%;
      border: 3px solid rgba(105, 111, 250, 0.2);
      border-top-color: var(--WeConnect-blue);
      animation: spin 1s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    /* Empty State */
    .empty-state { /* General empty state styling */
      text-align: center; padding: 2rem 1rem; /* Reduced padding slightly */
      color: var(--text-secondary); display: none;
      margin-top: 1rem; /* Adjusted margin */
    }
    .empty-state i { font-size: 2.5rem; color: #ccc; margin-bottom: 0.75rem; }
    .empty-state h3 { font-size: 1.1rem; margin-bottom: 0.4rem; color: var(--text-dark); }
    .empty-state p { font-size: 0.85rem; }


    /* Modal Styling */
    .modal-overlay {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background-color: rgba(0, 0, 0, 0.6); display: none;
      justify-content: center; align-items: center; z-index: 1100;
      opacity: 0; transition: opacity var(--transition-speed) ease;
    }
    .modal-overlay.active { display: flex; opacity: 1; }
    .modal-content {
      background-color: var(--card-background); border-radius: var(--border-radius-soft);
      width: 90%; max-width: 400px; padding: 0;
      box-shadow: 0 4px 15px rgba(0,0,0,0.2);
      position: relative; overflow: hidden; display: flex; flex-direction: column;
    }
    .modal-header {
      font-size: 1.2rem; font-weight: 600; padding: 1rem 1.25rem;
      border-bottom: 1px solid var(--separator-color);
      display: flex; align-items: center; gap: 0.75rem;
      flex-shrink: 0;
    }
    .modal-header .modal-user-avatar {
        width: 32px; height: 32px; border-radius: 50%;
        overflow: hidden; flex-shrink: 0; background-color: #e5e7eb;
    }
    .modal-header .modal-user-avatar img { width: 100%; height: 100%; object-fit: cover; }
     .modal-header .modal-title {
        flex-grow: 1; text-align: center;
        /* Adjust centering if avatar is present, else full center */
        /* margin-left: calc(-32px - 0.75rem); */ /* Only if avatar is always there */
        /* padding-right: calc(24px + 10px); */ /* Account for close button space */
    }
    .modal-close {
      position: absolute; top: 50%; right: 10px; transform: translateY(-50%);
      cursor: pointer; font-size: 1.8rem; color: var(--icon-color-inactive);
      line-height: 1; padding: 5px; border-radius: 50%;
      transition: background-color var(--transition-speed) ease, color var(--transition-speed) ease;
    }
    .modal-close:hover { color: var(--text-dark); background-color: #f0f0f0; }
    .modal-body {
        padding: 1rem 1.25rem;
        overflow-y: auto;
        flex-grow: 1;
    }
    .modal-textarea {
      width: 100%; padding: 0.7rem 0.9rem; margin-bottom: 1rem;
      border: 1px solid #ccc; border-radius: var(--border-radius-soft);
      font-size: 0.95rem; background-color: #fff;
      transition: border-color var(--transition-speed) ease;
      min-height: 80px; resize: vertical;
    }
    .modal-textarea:focus { border-color: var(--facebook-blue); outline: none; }
    .modal-button {
      width: 100%; padding: 0.75rem 1rem; background-color: var(--facebook-blue);
      color: white; border: none; border-radius: var(--border-radius-soft);
      cursor: pointer; font-size: 1rem; font-weight: 600;
      transition: background-color var(--transition-speed) ease;
      display: flex; align-items: center; justify-content: center; gap: 0.5rem;
    }
    .modal-button:hover { background-color: #166fe5; }
    .modal-button:disabled { background-color: #a0c3f0; cursor: not-allowed; }

    #aiGeneratedImagePreviewContainer img,
    #aiGeneratedImagePreviewContainer .loading-spinner-modal {
        max-width: 100%; max-height: 200px; display: block;
        margin: 10px auto; border-radius: var(--border-radius-soft);
    }
    .loading-spinner-modal { /* For use inside modals, smaller than full page spinner */
        width: 30px; height: 30px; border-radius: 50%;
        border: 3px solid rgba(var(--WeConnect-blue-rgb, 105, 111, 250), 0.3);
        border-top-color: var(--WeConnect-blue);
        animation: spin 1s linear infinite;
        margin: 10px auto;
    }


    /* Post Owner Actions */
    .post-owner-actions {
      margin-left: auto; display: flex; align-items: center; gap: 0.25rem;
    }
    .post-owner-actions button {
      background: none; border: none; cursor: pointer; color: var(--icon-color-inactive);
      font-size: 1.2rem; padding: 0.35rem; border-radius: 50%;
      line-height: 1;
      transition: background-color var(--transition-speed) ease, color var(--transition-speed) ease;
    }
     .post-owner-actions button:hover { background-color: #f0f0f0; color: var(--text-dark); }
     .post-owner-actions .edit-icon::before { content: 'edit'; font-family: 'Material Icons Outlined'; }
     .post-owner-actions .delete-icon::before { content: 'delete_outline'; font-family: 'Material Icons Outlined'; }

    /* Notification Banner */
    .notification-banner {
      position: fixed; top: calc(var(--header-height) + 10px); left: 50%;
      transform: translateX(-50%); background-color: rgba(0, 0, 0, 0.8);
      color: #fff; padding: 0.7rem 1.2rem; border-radius: var(--border-radius-pill);
      z-index: 1200; opacity: 0;
      transition: opacity 0.5s ease, top 0.5s ease;
      font-size: 0.85rem; pointer-events: none;
    }
    .notification-banner.show {
        opacity: 1; top: calc(var(--header-height) + 15px); pointer-events: auto;
    }
  </style>
  <script>
    // Prevent excessive zoom/tap events
    document.addEventListener('touchstart', e => { if (e.touches.length > 1) e.preventDefault(); }, { passive: false });
    document.addEventListener('touchmove', e => { if (e.touches.length > 1) e.preventDefault(); }, { passive: false });
    let lastTouchEnd = 0;
    document.addEventListener('touchend', e => {
      const now = Date.now();
      if (now - lastTouchEnd <= 300) e.preventDefault();
      lastTouchEnd = now;
    }, { passive: false });

    // Helper to parse --WeConnect-blue to RGB for box-shadow alpha
    document.addEventListener('DOMContentLoaded', () => {
        const weConnectBlue = getComputedStyle(document.documentElement).getPropertyValue('--WeConnect-blue').trim();
        if (weConnectBlue.startsWith('#')) {
            const hex = weConnectBlue.substring(1);
            const r = parseInt(hex.substring(0,2), 16);
            const g = parseInt(hex.substring(2,4), 16);
            const b = parseInt(hex.substring(4,6), 16);
            document.documentElement.style.setProperty('--WeConnect-blue-rgb', `${r}, ${g}, ${b}`);
        } else if (weConnectBlue.startsWith('rgb')) { // rgb(r, g, b)
             const parts = weConnectBlue.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
             if (parts) {
                document.documentElement.style.setProperty('--WeConnect-blue-rgb', `${parts[1]}, ${parts[2]}, ${parts[3]}`);
             }
        }
    });
  </script>
</head>
<body>
  <!-- Loading Overlay -->
  <div id="loadingOverlay" class="loading-overlay active">
    <div class="loading-spinner"></div>
  </div>

  <!-- Notification Banner -->
  <div id="notificationBanner" class="notification-banner"></div>

  <!-- Sticky Header -->
  <div class="sticky-header">
    <a href="home.html" class="header-icon-link header-back-button" title="Back">
      <span class="material-icons header-icon">arrow_back</span>
    </a>
    <a href="notifications.html" class="header-icon-link" title="Notifications">
      <span class="material-icons header-icon">notifications</span>
    </a>
    <a href="messenger.html" class="header-icon-link" title="Messenger">
      <span class="material-icons-outlined header-icon">chat_bubble_outline</span>
    </a>
    <div class="header-search-container">
        <span class="material-icons search-icon-inside">search</span>
        <input type="search" id="headerSearchInput" class="header-search-input" placeholder="Search posts...">
    </div>
  </div>

  <!-- Main Content Area -->
  <main class="flex-1 w-full">
    <!-- Inline Create Post Form -->
    <div id="createPostFormContainer" class="create-post-form-container">
      <div class="form-row">
        <div class="post-avatar">
          <a href="#" id="formUserAvatarLink">
            <img src="assets/images/user.png" alt="User Avatar" id="formUserAvatar" />
          </a>
        </div>
        <textarea id="formPostDescription" class="form-post-textarea" rows="3" placeholder="What's on your mind?"></textarea>
      </div>
      <div class="form-actions">
        <label for="formPostMediaFile" class="form-media-label">
            <span class="material-icons-outlined">add_photo_alternate</span> Add Photo/Video
        </label>
        <input id="formPostMediaFile" type="file" accept="image/*,video/*" style="display: none;"/>
        <button id="formSubmitPost" class="form-submit-button">Post</button>
      </div>
      <!-- Media Preview Area -->
      <div id="mediaPreviewContainer" style="display: none;">
        <!-- Preview will be injected here by JS -->
      </div>
      <!-- Media Enhancement Controls (shown with media preview) -->
      <div id="mediaEnhancementControls">
          <div id="imageBeautifyControls" style="display:none;">
              <h4>Beautify Image</h4>
              <label for="brightnessSlider">Brightness: <span id="brightnessValue">100</span>%</label>
              <input type="range" id="brightnessSlider" min="0" max="200" value="100">
              <label for="contrastSlider">Contrast: <span id="contrastValue">100</span>%</label>
              <input type="range" id="contrastSlider" min="0" max="200" value="100">
              <label for="saturateSlider">Saturation: <span id="saturateValue">100</span>%</label>
              <input type="range" id="saturateSlider" min="0" max="200" value="100">
              <button id="applyBeautifyBtn" class="form-tool-button small">Apply Filters</button>
              <button id="resetBeautifyBtn" class="form-tool-button small">Reset Filters</button>
          </div>
          <div id="videoEnhancementControls" style="display:none;">
              <h4>Video Options</h4>
              <label><input type="checkbox" id="videoPreviewFilterToggle"> Apply simple preview filter</label>
          </div>
          <div id="videoTrimControls" style="display:none; margin-top:0.5rem;">
              <h5>Trim Video</h5>
              <div id="videoTrimPreviewContainer" style="margin-bottom: 0.5rem;">
                  <video id="trimSourceVideo" style="width:100%; display:none;" controls></video>
              </div>
              <label for="trimStartTimeSlider">Start: <span id="trimStartTimeValue">0.0</span>s</label>
              <input type="range" id="trimStartTimeSlider" min="0" value="0" step="0.1">
              <label for="trimEndTimeSlider">End: <span id="trimEndTimeValue">0.0</span>s</label>
              <input type="range" id="trimEndTimeSlider" min="0" value="0" step="0.1">
              <p style="font-size:0.8rem; color: var(--text-secondary); margin-top: 0.5rem;">Note: Full client-side video trimming for upload requires advanced libraries (e.g., FFmpeg.wasm) or server-side processing. This UI selects trim points for potential use.</p>
          </div>
      </div>

      <div class="form-extra-actions">
          <button id="aiGenerateImageBtn" class="form-tool-button" title="Generate Image with AI">
              <span class="material-icons-outlined">auto_awesome</span> AI Image
          </button>
          <button id="aiEnhancePostBtn" class="form-tool-button" title="Enhance post text with AI">
              <span class="material-icons-outlined">edit_note</span> AI Enhance
          </button>
          <button id="recordVideoBtn" class="form-tool-button" title="Record Video">
              <span class="material-icons-outlined">videocam</span> Record
          </button>
      </div>
    </div>

    <!-- Stories & Reels Tabs -->
    <div class="stories-reels-tabs">
      <div class="tab-button active">Connects</div>
      <div class="tab-button">Feels</div>
    </div>
    <!-- Stories Container -->
    <div class="stories-container" id="storiesContainer">
      <div class="story-card create-story-card" id="createConnectCard">
        <a href="#" id="createConnectUserAvatarLink">
          <img class="user-avatar" src="assets/images/user.png" alt="Your Avatar" id="createConnectUserAvatar">
        </a>
        <div class="create-story-content">
          <div class="create-story-icon-wrapper"><span class="create-story-icon">+</span></div>
          <div class="create-story-label">Create connects</div>
        </div>
      </div>
    </div>
    <input type="file" id="connectFileInput" accept="image/*" style="display: none;">

    <!-- Post Feed -->
    <div id="postList" class="post-list">
      <!-- Posts loaded dynamically -->
    </div>
    <div class="empty-state" id="emptyState">
      <i class="material-icons">feed</i>
      <h3>No posts yet</h3>
      <p>Start connecting with others!</p>
    </div>
  </main>

  <!-- Edit Post Modal -->
  <div id="editPostModal" class="modal-overlay">
    <div class="modal-content">
       <div class="modal-header">
         <div class="modal-user-avatar">
             <img src="assets/images/user.png" alt="User Avatar" id="editModalUserAvatar" />
         </div>
         <span class="modal-title">Edit Post</span>
         <span id="editModalClose" class="modal-close material-icons-outlined">close</span>
       </div>
       <div class="modal-body">
          <textarea id="editPostDescription" class="modal-textarea" rows="4" placeholder="Edit your post"></textarea>
          <button id="updatePost" class="modal-button">Update</button>
       </div>
    </div>
  </div>

  <!-- AI Image Generation Modal -->
  <div id="aiImageModal" class="modal-overlay">
      <div class="modal-content">
          <div class="modal-header"><span class="modal-title">Generate Image with AI</span><span id="aiImageModalClose" class="modal-close material-icons-outlined">close</span></div>
          <div class="modal-body">
              <textarea id="aiImagePrompt" class="modal-textarea" rows="3" placeholder="Describe the image you want to generate... e.g., 'A majestic lion in a vibrant jungle sunset'"></textarea>
              <div id="aiGeneratedImagePreviewContainer" style="margin-bottom: 1rem; text-align: center; min-height: 100px;">
                  <!-- AI Generated Image or spinner will be shown here -->
              </div>
              <button id="submitAiImagePrompt" class="modal-button">Generate Image</button>
              <button id="useAiGeneratedImageBtn" class="modal-button" style="margin-top: 0.5rem; display: none; background-color: #45bd62;">Use This Image</button>
          </div>
      </div>
  </div>

  <!-- Video Recording Modal -->
  <div id="videoRecordModal" class="modal-overlay">
      <div class="modal-content">
          <div class="modal-header"><span class="modal-title">Record Video (Max 60s)</span><span id="videoRecordModalClose" class="modal-close material-icons-outlined">close</span></div>
          <div class="modal-body">
              <div style="text-align: center; margin-bottom: 1rem;">
                  <video id="videoRecordPreviewEl" autoplay muted playsinline style="width: 100%; max-height: 240px; background: #333; border-radius: var(--border-radius-soft);"></video>
              </div>
              <div id="videoRecordTimer" style="text-align: center; margin-bottom: 0.5rem; font-weight: bold;">0s / 60s</div>
              <button id="startRecordBtn" class="modal-button">Start Recording</button>
              <button id="stopRecordBtn" class="modal-button" style="display: none; background-color: var(--like-color);">Stop Recording</button>
              <div style="display: flex; gap: 0.5rem; margin-top: 0.5rem;">
                <button id="retakeVideoBtn" class="modal-button" style="display: none; background-color: var(--text-secondary); flex:1;">Retake</button>
                <button id="useRecordedVideoBtn" class="modal-button" style="display: none; background-color: #45bd62; flex:1;">Use Video</button>
              </div>
          </div>
      </div>
  </div>


  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.21.0/firebase-app.js";
    import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.21.0/firebase-auth.js";
    import { getFirestore, collection, getDocs, getDoc, addDoc, updateDoc, deleteDoc, serverTimestamp, query, orderBy, where, limit, doc, onSnapshot, runTransaction } from "https://www.gstatic.com/firebasejs/9.21.0/firebase-firestore.js";
    import { getStorage, ref as storageRef, uploadBytes, getDownloadURL } from "https://www.gstatic.com/firebasejs/9.21.0/firebase-storage.js";

    const TOGETHER_API_KEY = "023aa4d8437739df083d0f10537a8ff7aa0ddcda84fa89ab775c2cfd44c1681a"; // DO NOT REMOVE OR CHANGE
    const MODELS = { // DO NOT REMOVE OR CHANGE
        imageGen: "black-forest-labs/FLUX.1-schnell-Free", // "playgroundai/playground-v2.5-1024px-aesthetic" is another option
        chatCompletion: "meta-llama/Llama-3.3-70B-Instruct-Turbo-Free",
        thinking: "deepseek-ai/DeepSeek-R1-Distill-Llama-70B-free",
        vision: "meta-llama/Llama-Vision-Free"
    };

    const firebaseConfig = {
      apiKey: "AIzaSyDwldURmtljNpORmpGRacwXriPmQZjF6j8", // KEEP YOUR CONFIG
      authDomain: "daisy-n7g20a.firebaseapp.com",
      databaseURL: "https://daisy-n7g20a-default-rtdb.firebaseio.com",
      projectId: "daisy-n7g20a",
      storageBucket: "daisy-n7g20a.appspot.com",
      messagingSenderId: "225362605902",
      appId: "1:225362605902:web:d2551cc389e78c92c3d01f"
    };
    let app, auth, db, storage;
    try {
      app = initializeApp(firebaseConfig);
      auth = getAuth(app);
      db = getFirestore(app);
      storage = getStorage(app);
      console.log("Firebase Initialized Successfully for Social Page");
    } catch (error) {
      console.error("Firebase Initialization Failed:", error);
      document.getElementById("loadingOverlay")?.classList.remove("active");
      const body = document.querySelector('body');
      if (body) body.innerHTML = '<div style="padding: 20px; text-align: center; color: red;">Critical error: Could not initialize application services. Please try again later.</div>';
    }

    const loadingOverlay = document.getElementById("loadingOverlay");
    const postList = document.getElementById("postList");
    const emptyState = document.getElementById("emptyState");
    const headerSearchInputEl = document.getElementById('headerSearchInput');

    const formPostDescriptionEl = document.getElementById("formPostDescription");
    const formPostMediaFileEl = document.getElementById("formPostMediaFile");
    const formSubmitPostBtn = document.getElementById("formSubmitPost");
    const formUserAvatar = document.getElementById("formUserAvatar");
    const formUserAvatarLink = document.getElementById("formUserAvatarLink");
    const mediaPreviewContainer = document.getElementById('mediaPreviewContainer');

    // New feature elements
    const aiGenerateImageBtn = document.getElementById('aiGenerateImageBtn');
    const aiEnhancePostBtn = document.getElementById('aiEnhancePostBtn');
    const recordVideoBtn = document.getElementById('recordVideoBtn');

    const aiImageModal = document.getElementById('aiImageModal');
    const aiImageModalClose = document.getElementById('aiImageModalClose');
    const aiImagePromptEl = document.getElementById('aiImagePrompt');
    const aiGeneratedImagePreviewContainer = document.getElementById('aiGeneratedImagePreviewContainer');
    const submitAiImagePromptBtn = document.getElementById('submitAiImagePrompt');
    const useAiGeneratedImageBtn = document.getElementById('useAiGeneratedImageBtn');

    const videoRecordModal = document.getElementById('videoRecordModal');
    const videoRecordModalClose = document.getElementById('videoRecordModalClose');
    const videoRecordPreviewEl = document.getElementById('videoRecordPreviewEl');
    const videoRecordTimerEl = document.getElementById('videoRecordTimer');
    const startRecordBtn = document.getElementById('startRecordBtn');
    const stopRecordBtn = document.getElementById('stopRecordBtn');
    const useRecordedVideoBtn = document.getElementById('useRecordedVideoBtn');
    const retakeVideoBtn = document.getElementById('retakeVideoBtn');

    const mediaEnhancementControlsEl = document.getElementById('mediaEnhancementControls');
    const imageBeautifyControlsEl = document.getElementById('imageBeautifyControls');
    const brightnessSlider = document.getElementById('brightnessSlider');
    const brightnessValueEl = document.getElementById('brightnessValue');
    const contrastSlider = document.getElementById('contrastSlider');
    const contrastValueEl = document.getElementById('contrastValue');
    const saturateSlider = document.getElementById('saturateSlider');
    const saturateValueEl = document.getElementById('saturateValue');
    const applyBeautifyBtn = document.getElementById('applyBeautifyBtn');
    const resetBeautifyBtn = document.getElementById('resetBeautifyBtn');

    const videoEnhancementControlsContainerEl = document.getElementById('videoEnhancementControls'); // The parent of video specific controls
    const videoPreviewFilterToggle = document.getElementById('videoPreviewFilterToggle');
    const videoTrimControlsEl = document.getElementById('videoTrimControls');
    const trimSourceVideoEl = document.getElementById('trimSourceVideo');
    const trimStartTimeSlider = document.getElementById('trimStartTimeSlider');
    const trimStartTimeValueEl = document.getElementById('trimStartTimeValue');
    const trimEndTimeSlider = document.getElementById('trimEndTimeSlider');
    const trimEndTimeValueEl = document.getElementById('trimEndTimeValue');


    const editPostModal = document.getElementById("editPostModal");
    const editModalClose = document.getElementById("editModalClose");
    const updatePostBtn = document.getElementById("updatePost");
    const editPostDescriptionEl = document.getElementById("editPostDescription");
    const connectFileInput = document.getElementById("connectFileInput");
    const storiesContainer = document.getElementById("storiesContainer");
    const createConnectCard = document.getElementById("createConnectCard");
    const notificationBanner = document.getElementById("notificationBanner");
    const createConnectUserAvatar = document.getElementById("createConnectUserAvatar");
    const createConnectUserAvatarLink = document.getElementById("createConnectUserAvatarLink");
    const editModalUserAvatar = document.getElementById("editModalUserAvatar");

    let currentUser = null;
    let currentUserProfile = null;
    let userLikes = {};
    let postsDataGlobal = {};
    let editPostId = null;

    let mediaFileForUpload = null; // Holds File object from direct input, AI gen, or recording
    let originalImageForBeautify = null; // Stores original Image object for reset
    let currentPreviewType = null; // 'image' or 'video'

    // MediaRecorder variables
    let mediaRecorder;
    let recordedChunks = [];
    let recordingTimerInterval;
    let recordingStartTime;
    const MAX_RECORDING_TIME_MS = 60000; // 60 seconds

    function showNotification(message) {
      if (!notificationBanner) return;
      notificationBanner.textContent = message;
      notificationBanner.classList.add("show");
      setTimeout(() => notificationBanner.classList.remove("show"), 3000);
    }

    function updateUserAvatars(profileData) {
      const defaultAvatar = 'assets/images/user.png';
      const avatarUrl = profileData?.photo || defaultAvatar;
      const profileLinkBase = "user-profile.html";
      const userProfileLink = profileData?.uid ? `${profileLinkBase}?uid=${profileData.uid}` : "#";

      if (formUserAvatar) formUserAvatar.src = avatarUrl;
      if (formUserAvatarLink) formUserAvatarLink.href = userProfileLink;
      if (formPostDescriptionEl && profileData) {
        formPostDescriptionEl.placeholder = `What's on your mind, ${profileData.displayName ? profileData.displayName.split(' ')[0] : 'User'}?`;
      } else if (formPostDescriptionEl) {
        formPostDescriptionEl.placeholder = "What's on your mind?";
      }
      if (createConnectUserAvatar) createConnectUserAvatar.src = avatarUrl;
      if (createConnectUserAvatarLink) createConnectUserAvatarLink.href = userProfileLink;
      if (editModalUserAvatar) editModalUserAvatar.src = avatarUrl;
    }

    function showEmptyState(message = "No posts yet", subMessage = "Start connecting with others!") {
        const searchEmptyEl = document.getElementById('searchEmptyStateInList');
        if (searchEmptyEl) searchEmptyEl.style.display = 'none';
        if (postList) postList.innerHTML = "";
        if (emptyState) {
            emptyState.style.display = 'block';
            emptyState.querySelector('h3').textContent = message;
            emptyState.querySelector('p').textContent = subMessage;
        }
    }
    function hideEmptyState() { if (emptyState) emptyState.style.display = 'none'; }
    function formatTimestamp(timestamp) {
        if (!timestamp || typeof timestamp.toDate !== 'function') return "just now";
        const date = timestamp.toDate(); const now = new Date();
        const secondsPast = (now.getTime() - date.getTime()) / 1000;
        if (secondsPast < 5) return 'Just now';
        if (secondsPast < 60) return `${Math.round(secondsPast)}s ago`;
        if (secondsPast < 3600) return `${Math.round(secondsPast / 60)}m ago`;
        if (secondsPast < 86400) return `${Math.round(secondsPast / 3600)}h ago`;
        if (secondsPast < 604800) return `${Math.round(secondsPast / 86400)}d ago`;
        const options = { month: 'short', day: 'numeric' };
        if (date.getFullYear() !== now.getFullYear()) options.year = 'numeric';
        return date.toLocaleDateString(undefined, options);
    }
    function formatPostContent(text) {
      if (!text) return '';
      const escapedText = text.replace(/&/g, "&").replace(/</g, "<").replace(/>/g, ">");
      const linkedText = escapedText.replace(/(https?:\/\/[^\s]+)/g, '<a href="$1" target="_blank" rel="noopener noreferrer" style="color: var(--facebook-blue); text-decoration: underline;">$1</a>');
      return linkedText.replace(/\n/g, '<br>');
    }
    function escapeHTML(str) {
        const div = document.createElement('div');
        div.appendChild(document.createTextNode(str));
        return div.innerHTML;
    }

    // --- New Feature: AI & Media Handling ---

    function base64ToBlob(base64, type = 'image/png') {
        const byteCharacters = atob(base64);
        const byteNumbers = new Array(byteCharacters.length);
        for (let i = 0; i < byteCharacters.length; i++) {
            byteNumbers[i] = byteCharacters.charCodeAt(i);
        }
        const byteArray = new Uint8Array(byteNumbers);
        return new Blob([byteArray], {type: type});
    }

    function displayMediaPreview(file) {
        if (!mediaPreviewContainer) return;
        mediaPreviewContainer.innerHTML = ''; // Clear previous
        mediaFileForUpload = file; // This is the file that will be uploaded
        formPostMediaFileEl.value = ''; // Clear file input as we are using mediaFileForUpload

        let mediaElement;
        const objectURL = URL.createObjectURL(file);

        if (file.type.startsWith('image/')) {
            currentPreviewType = 'image';
            mediaElement = document.createElement('img');
            mediaElement.src = objectURL;
            mediaElement.onload = () => {
                 // Store original for beautify reset
                originalImageForBeautify = new Image();
                originalImageForBeautify.onload = () => {
                    // Now it's fully loaded and can be drawn to canvas later
                    resetBeautifyFilters(false); // Reset sliders but don't redraw yet
                };
                originalImageForBeautify.src = objectURL;
            }
            mediaEnhancementControlsEl.style.display = 'block';
            imageBeautifyControlsEl.style.display = 'block';
            videoEnhancementControlsContainerEl.style.display = 'none';
            videoTrimControlsEl.style.display = 'none';

        } else if (file.type.startsWith('video/')) {
            currentPreviewType = 'video';
            mediaElement = document.createElement('video');
            mediaElement.src = objectURL;
            mediaElement.controls = true;
            mediaElement.preload = "metadata";
            
            mediaElement.onloadedmetadata = () => {
                trimSourceVideoEl.src = objectURL; // Also set for trim preview
                setupVideoTrimControls(mediaElement.duration);
            };

            mediaEnhancementControlsEl.style.display = 'block';
            imageBeautifyControlsEl.style.display = 'none';
            videoEnhancementControlsContainerEl.style.display = 'block'; // Show general video options
            videoTrimControlsEl.style.display = 'block'; // Show trim controls
        }

        if (mediaElement) {
            mediaPreviewContainer.appendChild(mediaElement);
            mediaPreviewContainer.style.display = 'block';
        } else {
            mediaPreviewContainer.style.display = 'none';
            mediaEnhancementControlsEl.style.display = 'none';
            mediaFileForUpload = null;
        }
    }
    
    function displayCanvasPreview(canvas) { // For beautified image
        if (!mediaPreviewContainer) return;
        mediaPreviewContainer.innerHTML = '';
        mediaPreviewContainer.appendChild(canvas);
        mediaPreviewContainer.style.display = 'block';
        // The mediaFileForUpload should be updated with the blob from this canvas
    }

    aiGenerateImageBtn?.addEventListener('click', () => {
        if (!currentUser) { showNotification("Please log in to use AI features."); return; }
        aiImagePromptEl.value = '';
        aiGeneratedImagePreviewContainer.innerHTML = '';
        useAiGeneratedImageBtn.style.display = 'none';
        submitAiImagePromptBtn.disabled = false;
        submitAiImagePromptBtn.textContent = 'Generate Image';
        aiImageModal.classList.add('active');
    });
    aiImageModalClose?.addEventListener('click', () => aiImageModal.classList.remove('active'));

    submitAiImagePromptBtn?.addEventListener('click', async () => {
        const prompt = aiImagePromptEl.value.trim();
        if (!prompt) {
            showNotification("Please enter a prompt for the image.");
            return;
        }
        submitAiImagePromptBtn.disabled = true;
        submitAiImagePromptBtn.innerHTML = 'Generating... <span class="upload-spinner-inline"></span>';
        aiGeneratedImagePreviewContainer.innerHTML = '<div class="loading-spinner-modal"></div>';
        useAiGeneratedImageBtn.style.display = 'none';

        try {
            const response = await fetch('https://api.together.xyz/v1/images/generations', { // Or /inference if needed for specific models
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${TOGETHER_API_KEY}`
                },
                body: JSON.stringify({
                    model: MODELS.imageGen,
                    prompt: prompt,
                    n: 1,
                    // steps: 25, // Default for FLUX.1-schnell is 10, can be up to 50. Higher = slower, potentially better.
                    // width: 1024, height: 1024, // Check model specifics for supported sizes
                })
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({ message: response.statusText }));
                throw new Error(`API Error (${response.status}): ${errorData.message || 'Failed to generate image'}`);
            }
            const data = await response.json();
            
            // FLUX.1-schnell returns base64 directly in data[0].b64image
            // Other models might be data.output.choices[0].image_base64
            const base64Image = data[0]?.b64image || data.output?.choices?.[0]?.image_base64;

            if (base64Image) {
                const img = document.createElement('img');
                img.src = `data:image/png;base64,${base64Image}`;
                aiGeneratedImagePreviewContainer.innerHTML = '';
                aiGeneratedImagePreviewContainer.appendChild(img);
                useAiGeneratedImageBtn.style.display = 'block';
                useAiGeneratedImageBtn.onclick = () => {
                    const imageBlob = base64ToBlob(base64Image, 'image/png');
                    const fileName = `ai_generated_${Date.now()}.png`;
                    const aiImageFile = new File([imageBlob], fileName, { type: 'image/png' });
                    displayMediaPreview(aiImageFile);
                    aiImageModal.classList.remove('active');
                    showNotification("AI Image selected for your post.");
                };
            } else {
                throw new Error('No image data received from API.');
            }
        } catch (error) {
            console.error("AI Image Generation Error:", error);
            showNotification(`Error generating image: ${error.message}`);
            aiGeneratedImagePreviewContainer.innerHTML = `<p style="color:red;">${error.message}</p>`;
        } finally {
            submitAiImagePromptBtn.disabled = false;
            submitAiImagePromptBtn.innerHTML = 'Generate Image';
        }
    });

    aiEnhancePostBtn?.addEventListener('click', async () => {
        if (!currentUser) { showNotification("Please log in to use AI features."); return; }
        const currentText = formPostDescriptionEl.value;
        if (!currentText.trim()) {
            showNotification("Write something first to enhance it.");
            return;
        }
        aiEnhancePostBtn.disabled = true;
        aiEnhancePostBtn.innerHTML = '<span class="material-icons-outlined">edit_note</span> AI Enhancing...';
        const originalButtonText = '<span class="material-icons-outlined">edit_note</span> AI Enhance';


        try {
            const response = await fetch('https://api.together.xyz/v1/chat/completions', { // Standard chat completions endpoint
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${TOGETHER_API_KEY}`
                },
                body: JSON.stringify({
                    model: MODELS.chatCompletion,
                    messages: [
                        { role: "system", content: "You are a helpful assistant that enhances social media posts. Make them more engaging, concise, and impactful. Return only the enhanced post content, without any introductory phrases like 'Here's the enhanced post:'." },
                        { role: "user", content: `Enhance this social media post: "${currentText}"` }
                    ],
                    max_tokens: 200, // Adjust as needed
                    temperature: 0.7
                })
            });
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({ message: response.statusText }));
                throw new Error(`API Error (${response.status}): ${errorData.error?.message || errorData.message || 'Failed to enhance post'}`);
            }
            const data = await response.json();
            const enhancedText = data.choices?.[0]?.message?.content?.trim();
            if (enhancedText) {
                formPostDescriptionEl.value = enhancedText;
                showNotification("Post enhanced by AI!");
            } else {
                throw new Error('No enhanced text received from API.');
            }
        } catch (error) {
            console.error("AI Post Enhancement Error:", error);
            showNotification(`Error enhancing post: ${error.message}`);
        } finally {
            aiEnhancePostBtn.disabled = false;
            aiEnhancePostBtn.innerHTML = originalButtonText;
        }
    });

    // Video Recording Logic
    recordVideoBtn?.addEventListener('click', () => {
        if (!currentUser) { showNotification("Please log in to record video."); return; }
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            showNotification("Video recording is not supported by your browser.");
            return;
        }
        videoRecordModal.classList.add('active');
        resetVideoRecorderUI();
        startPreview();
    });

    videoRecordModalClose?.addEventListener('click', () => {
        stopPreviewAndRecording();
        videoRecordModal.classList.remove('active');
    });
    
    async function startPreview() {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
            videoRecordPreviewEl.srcObject = stream;
            videoRecordPreviewEl.captureStream = videoRecordPreviewEl.captureStream || videoRecordPreviewEl.mozCaptureStream; // For Firefox
            startRecordBtn.style.display = 'block';
            stopRecordBtn.style.display = 'none';
            useRecordedVideoBtn.style.display = 'none';
            retakeVideoBtn.style.display = 'none';
            videoRecordTimerEl.textContent = `0s / ${MAX_RECORDING_TIME_MS/1000}s`;
        } catch (err) {
            console.error("Error accessing media devices.", err);
            showNotification("Could not access camera/microphone: " + err.message);
            videoRecordModal.classList.remove('active');
        }
    }

    function stopPreviewAndRecording() {
        if (videoRecordPreviewEl.srcObject) {
            videoRecordPreviewEl.srcObject.getTracks().forEach(track => track.stop());
            videoRecordPreviewEl.srcObject = null;
        }
        if (mediaRecorder && mediaRecorder.state !== "inactive") {
            mediaRecorder.stop();
        }
        clearInterval(recordingTimerInterval);
    }
    
    function resetVideoRecorderUI() {
        startRecordBtn.style.display = 'block';
        stopRecordBtn.style.display = 'none';
        useRecordedVideoBtn.style.display = 'none';
        retakeVideoBtn.style.display = 'none';
        videoRecordTimerEl.textContent = `0s / ${MAX_RECORDING_TIME_MS/1000}s`;
        videoRecordPreviewEl.classList.remove('recording-active'); // Optional: for styling
        recordedChunks = [];
    }


    startRecordBtn?.addEventListener('click', () => {
        if (!videoRecordPreviewEl.srcObject) {
            showNotification("Preview not started. Cannot record.");
            return;
        }
        recordedChunks = [];
        const stream = videoRecordPreviewEl.srcObject;
        mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm;codecs=vp8,opus' }); // Common format

        mediaRecorder.ondataavailable = (event) => {
            if (event.data.size > 0) {
                recordedChunks.push(event.data);
            }
        };

        mediaRecorder.onstop = () => {
            const videoBlob = new Blob(recordedChunks, { type: 'video/webm' });
            videoRecordPreviewEl.srcObject = null; // Stop live preview
            videoRecordPreviewEl.src = URL.createObjectURL(videoBlob); // Show recorded video
            videoRecordPreviewEl.muted = false;
            videoRecordPreviewEl.controls = true;

            startRecordBtn.style.display = 'none';
            stopRecordBtn.style.display = 'none';
            useRecordedVideoBtn.style.display = 'flex';
            retakeVideoBtn.style.display = 'flex';
            clearInterval(recordingTimerInterval);
        };
        
        mediaRecorder.start();
        recordingStartTime = Date.now();
        videoRecordTimerEl.textContent = `Recording... 0s / ${MAX_RECORDING_TIME_MS/1000}s`;
        recordingTimerInterval = setInterval(() => {
            const elapsedTime = Date.now() - recordingStartTime;
            videoRecordTimerEl.textContent = `Recording... ${Math.floor(elapsedTime / 1000)}s / ${MAX_RECORDING_TIME_MS/1000}s`;
            if (elapsedTime >= MAX_RECORDING_TIME_MS) {
                stopRecordBtn.click(); // Auto-stop
            }
        }, 1000);

        startRecordBtn.style.display = 'none';
        stopRecordBtn.style.display = 'block';
    });

    stopRecordBtn?.addEventListener('click', () => {
        if (mediaRecorder && mediaRecorder.state === "recording") {
            mediaRecorder.stop();
        }
        clearInterval(recordingTimerInterval);
    });

    useRecordedVideoBtn?.addEventListener('click', () => {
        if (recordedChunks.length === 0) {
            showNotification("No video recorded."); return;
        }
        const videoBlob = new Blob(recordedChunks, { type: 'video/webm' });
        const videoFile = new File([videoBlob], `recorded_video_${Date.now()}.webm`, { type: 'video/webm' });
        displayMediaPreview(videoFile);
        stopPreviewAndRecording();
        videoRecordModal.classList.remove('active');
        showNotification("Recorded video selected for your post.");
    });
    
    retakeVideoBtn?.addEventListener('click', () => {
        stopPreviewAndRecording(); // Stop current recording/preview if any
        resetVideoRecorderUI();
        videoRecordPreviewEl.src = null; // Clear recorded preview
        videoRecordPreviewEl.controls = false;
        videoRecordPreviewEl.muted = true;
        startPreview(); // Restart camera preview for new recording
    });


    // Image Beautification
    function applyImageFiltersToCanvas(image, brightness, contrast, saturate) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = image.naturalWidth || image.width; // Use naturalWidth for original img, width for canvas/video
        canvas.height = image.naturalHeight || image.height;
        
        ctx.filter = `brightness(${brightness}%) contrast(${contrast}%) saturate(${saturate}%)`;
        ctx.drawImage(image, 0, 0, canvas.width, canvas.height);
        return canvas;
    }

    function updateFilterValuesDisplay() {
        if (brightnessValueEl) brightnessValueEl.textContent = brightnessSlider.value;
        if (contrastValueEl) contrastValueEl.textContent = contrastSlider.value;
        if (saturateValueEl) saturateValueEl.textContent = saturateSlider.value;
    }
    
    [brightnessSlider, contrastSlider, saturateSlider].forEach(slider => {
        slider?.addEventListener('input', () => {
            updateFilterValuesDisplay();
            if (currentPreviewType === 'image' && mediaPreviewContainer.querySelector('img')) {
                 // Live preview for image using CSS filters on the preview element
                mediaPreviewContainer.querySelector('img').style.filter = `brightness(${brightnessSlider.value}%) contrast(${contrastSlider.value}%) saturate(${saturateSlider.value}%)`;
            }
        });
    });

    applyBeautifyBtn?.addEventListener('click', () => {
        if (currentPreviewType !== 'image' || !originalImageForBeautify || !originalImageForBeautify.complete || originalImageForBeautify.naturalWidth === 0) {
            showNotification("Please select an image first to apply filters.");
            return;
        }
        const b = brightnessSlider.value;
        const c = contrastSlider.value;
        const s = saturateSlider.value;

        const filteredCanvas = applyImageFiltersToCanvas(originalImageForBeautify, b, c, s);
        displayCanvasPreview(filteredCanvas); // Show canvas in main preview
        
        filteredCanvas.toBlob(blob => {
            mediaFileForUpload = new File([blob], `beautified_${mediaFileForUpload?.name || Date.now()}.png`, { type: 'image/png' });
            showNotification("Image filters applied. The beautified image will be uploaded.");
        }, 'image/png');
    });

    function resetBeautifyFilters(redraw = true) {
        brightnessSlider.value = 100;
        contrastSlider.value = 100;
        saturateSlider.value = 100;
        updateFilterValuesDisplay();

        const imgPreview = mediaPreviewContainer.querySelector('img');
        const canvasPreview = mediaPreviewContainer.querySelector('canvas');

        if (imgPreview) imgPreview.style.filter = 'none'; // Remove live CSS filters

        if (redraw && currentPreviewType === 'image' && originalImageForBeautify && mediaFileForUpload?.type.startsWith('image')) {
             // Revert to original image if it was an image file initially
             displayMediaPreview(mediaFileForUpload); // This uses the stored mediaFileForUpload which should be original before beautify.
                                                    // Or, if you want to ensure it's the absolute original:
             // const originalBlob = ... (need to store original blob/file separately if mediaFileForUpload was overwritten by AI/Record)
             // For simplicity, this re-runs displayMediaPreview with the current mediaFileForUpload, assuming it's the source
             // before the *last* beautification attempt.
             // To truly reset to the very first file selected, that file needs to be stored persistently.
             // For now, it resets to the version before *this* beautification was applied from originalImageForBeautify.
             if (originalImageForBeautify) {
                mediaPreviewContainer.innerHTML = '';
                mediaPreviewContainer.appendChild(originalImageForBeautify.cloneNode()); // Clone to avoid issues if original is used elsewhere
                mediaPreviewContainer.querySelector('img').style.filter = 'none'; // Ensure no CSS filters
                // Re-assign mediaFileForUpload to original if it was changed to a beautified blob
                // This requires storing the initial file more robustly.
                // For now, this reset primarily targets the visual and filter values.
             }
        } else if (canvasPreview) { // If currently showing a canvas, revert to original image
            if (originalImageForBeautify) {
                mediaPreviewContainer.innerHTML = '';
                mediaPreviewContainer.appendChild(originalImageForBeautify.cloneNode());
            }
        }
         showNotification("Filters reset.");
    }
    resetBeautifyBtn?.addEventListener('click', () => resetBeautifyFilters(true));


    // Video Enhancement (Preview Filter) & Trimming UI
    videoPreviewFilterToggle?.addEventListener('change', (e) => {
        const videoPreviewInMain = mediaPreviewContainer.querySelector('video');
        if (videoPreviewInMain) {
            videoPreviewInMain.classList.toggle('filtered', e.target.checked);
        }
    });

    function setupVideoTrimControls(duration) {
        if (isNaN(duration) || duration <= 0) {
            videoTrimControlsEl.style.display = 'none';
            return;
        }
        videoTrimControlsEl.style.display = 'block';
        trimStartTimeSlider.max = duration.toFixed(1);
        trimEndTimeSlider.max = duration.toFixed(1);
        
        trimStartTimeSlider.value = 0;
        trimEndTimeSlider.value = duration.toFixed(1);

        trimStartTimeValueEl.textContent = (0).toFixed(1);
        trimEndTimeValueEl.textContent = duration.toFixed(1);
        
        trimSourceVideoEl.currentTime = 0; // Reset preview
    }

    trimStartTimeSlider?.addEventListener('input', (e) => {
        const startTime = parseFloat(e.target.value);
        const endTime = parseFloat(trimEndTimeSlider.value);
        if (startTime >= endTime) {
            e.target.value = (endTime - 0.1).toFixed(1) < 0 ? 0 : (endTime - 0.1).toFixed(1) ;
        }
        trimStartTimeValueEl.textContent = parseFloat(e.target.value).toFixed(1);
        if(trimSourceVideoEl.paused) trimSourceVideoEl.currentTime = parseFloat(e.target.value);
    });

    trimEndTimeSlider?.addEventListener('input', (e) => {
        const endTime = parseFloat(e.target.value);
        const startTime = parseFloat(trimStartTimeSlider.value);
        if (endTime <= startTime) {
            e.target.value = (startTime + 0.1).toFixed(1) > parseFloat(trimEndTimeSlider.max) ? trimEndTimeSlider.max : (startTime + 0.1).toFixed(1);
        }
        trimEndTimeValueEl.textContent = parseFloat(e.target.value).toFixed(1);
         if(trimSourceVideoEl.paused) trimSourceVideoEl.currentTime = parseFloat(e.target.value);
    });


    // --- End New Feature: AI & Media Handling ---


    async function loadConnects() { /* ... (no changes) ... */
      if (!db || !storiesContainer) return;
      const connectsRef = collection(db, "connects");
      const q = query(connectsRef, orderBy("createdAt", "desc"), limit(15));
      try {
        const snapshot = await getDocs(q);
        const connectsData = snapshot.docs.map(docSnap => ({ id: docSnap.id, ...docSnap.data() }));
        renderConnects(connectsData);
      } catch (error) { console.error("Error loading connects:", error); }
    }
    function clearConnects() { /* ... (no changes) ... */
        if (!storiesContainer) return;
        const existingConnects = storiesContainer.querySelectorAll('.story-card:not(.create-story-card)');
        existingConnects.forEach(card => card.remove());
    }
    function renderConnects(connects) { /* ... (no changes) ... */
      if (!storiesContainer || !createConnectCard) return;
      clearConnects();
      connects.forEach(connect => {
        const connectCard = document.createElement('div');
        connectCard.className = 'story-card';
        connectCard.dataset.connectId = connect.id;
        connectCard.innerHTML = `
          <div class="story-avatar">
            <a href="user-profile.html?uid=${connect.authorId || ''}">
              <img src="${connect.authorAvatarUrl || 'assets/images/user.png'}" alt="${connect.authorName || 'User'}">
            </a>
          </div>
          <img class="story-bg" src="${connect.imageUrl}" alt="Connect by ${connect.authorName || 'User'}">
          <div class="story-author-name">${connect.authorName || 'Anonymous'}</div>
        `;
        connectCard.addEventListener('click', () => {
          showNotification(`Viewing connect from ${connect.authorName || 'Anonymous'}`);
        });
        createConnectCard.insertAdjacentElement('afterend', connectCard);
      });
       const dynamicConnects = Array.from(storiesContainer.querySelectorAll('.story-card:not(.create-story-card)'));
       dynamicConnects.reverse().forEach(card => storiesContainer.appendChild(card));
    }
    async function createConnect(file) { /* ... (no changes) ... */
        if (!currentUser) { showNotification("Please log in to create a connect."); if (connectFileInput) connectFileInput.value = ''; return; }
        if (!file || !storage || !db || !currentUserProfile) { showNotification("Cannot create connect. Profile not loaded or service unavailable."); if (connectFileInput) connectFileInput.value = ''; return; }
        loadingOverlay?.classList.add('active');
        if (createConnectCard) { createConnectCard.style.opacity = '0.5'; createConnectCard.style.pointerEvents = 'none'; }
        try {
            const filePath = `connects/${currentUserProfile.uid}/${Date.now()}_${file.name}`;
            const fileRef = storageRef(storage, filePath);
            const uploadSnapshot = await uploadBytes(fileRef, file);
            const imageUrl = await getDownloadURL(uploadSnapshot.ref);
            await addDoc(collection(db, "connects"), {
                imageUrl: imageUrl,
                authorId: currentUserProfile.uid,
                authorName: currentUserProfile.displayName || "Anonymous",
                authorAvatarUrl: currentUserProfile.photo || 'assets/images/user.png',
                createdAt: serverTimestamp()
            });
            await loadConnects();
            showNotification("Connect created successfully!");
        } catch (error) {
            console.error("Error creating connect:", error);
            showNotification(`Failed to create connect: ${error.message}`);
        } finally {
            loadingOverlay?.classList.remove("active");
            if (createConnectCard) { createConnectCard.style.opacity = '1'; createConnectCard.style.pointerEvents = 'auto'; }
            if (connectFileInput) connectFileInput.value = '';
        }
    }

    async function loadPosts() {
      if (!db) return;
      try {
        const postsRef = collection(db, "social");
        const q = query(postsRef, orderBy("createdAt", "desc"), limit(20));
        const snapshot = await getDocs(q);
        let postsData = snapshot.docs.map(docSnap => ({ id: docSnap.id, ...docSnap.data() }));
        
        postsDataGlobal = {};
        snapshot.docs.forEach(docSnap => postsDataGlobal[docSnap.id] = { id: docSnap.id, ...docSnap.data() });

        if (currentUser) { await fetchUserLikesForPosts(postsData.map(p => p.id)); }
        else { userLikes = {}; }

        if (postsData.length === 0 && !headerSearchInputEl?.value) {
            showEmptyState(); 
        } else if (postsData.length > 0) {
            renderPosts(postsData);
            hideEmptyState();
        } else {
            postList.innerHTML = "";
            hideEmptyState();
        }
      } catch (error) {
        console.error("Error loading posts:", error);
        showEmptyState("Error loading posts.", "Please try again later.");
      } finally {
        setTimeout(() => loadingOverlay?.classList.remove("active"), 300);
        const currentSearchTerm = headerSearchInputEl?.value;
        if (currentSearchTerm && currentSearchTerm.trim() !== '') {
            filterPostsOnPage(currentSearchTerm.toLowerCase().trim());
        } else if (Object.keys(postsDataGlobal).length === 0) {
            showEmptyState();
        } else if (Object.keys(postsDataGlobal).length > 0) {
             hideEmptyState();
        }
      }
    }
    async function fetchUserLikesForPosts(postIds) { /* ... (no changes) ... */
      if (!currentUser || postIds.length === 0 || !db) return;
      const likePromises = postIds.map(postId => {
          if (userLikes[postId] === undefined) { 
              const likeRef = doc(db, "social", postId, "likes", currentUser.uid);
              return getDoc(likeRef).then(likeSnap => ({ postId, exists: likeSnap.exists() }));
          }
          return Promise.resolve(null); 
      });
      try {
        const results = await Promise.all(likePromises.filter(p => p !== null));
        results.forEach(result => { if (result) userLikes[result.postId] = result.exists; });
      } catch (error) { console.error("Error fetching user likes:", error); }
    }
    function renderPosts(postsToRender) {
      if (!postList) return;
      postList.innerHTML = ""; 
      if (postsToRender.length === 0 && !headerSearchInputEl?.value) {
         return;
      }
      postsToRender.forEach(post => {
        const postEl = createPostElement(post);
        postList.appendChild(postEl);
      });
    }

    function createPostElement(post) {
      const postEl = document.createElement("div");
      postEl.className = "post-card";
      postEl.dataset.postId = post.id;

      const hasLiked = currentUser ? (userLikes[post.id] === true) : false;
      const likeCount = post.likeCount || 0;
      const commentCount = post.commentCount || 0;
      const commentAvatarUrl = currentUserProfile?.photo || 'assets/images/user.png';

      const avatarHtml = `
        <div class="post-avatar">
          <a href="user-profile.html?uid=${post.authorId || ''}">
            <img src="${post.authorAvatarUrl || 'assets/images/user.png'}" alt="${post.author || 'Author'} Avatar" />
          </a>
        </div>`;
      let ownerActionsHtml = (currentUser && post.authorId === currentUser.uid) ? `
          <div class="post-owner-actions">
             <button class="edit-icon" title="Edit Post" onclick="window.handleEditPost('${post.id}')"></button>
             <button class="delete-icon" title="Delete Post" onclick="window.handleDeletePost('${post.id}')"></button>
          </div>` : "";
      const likesDisplayHtml = likeCount > 0 ? `<span class="material-icons like-icon-filled">thumb_up</span> ${likeCount}` : '';
      const commentsDisplayHtml = commentCount > 0 ? `${commentCount} Comment${commentCount > 1 ? 's' : ''}` : '';
      const mediaHtml = post.mediaUrl ?
        `<div class="post-media">
            ${post.mediaType === 'video' ?
                `<video src="${post.mediaUrl}" controls preload="metadata"></video>` :
                `<img src="${post.mediaUrl}" alt="Post Media" class="${post.mediaType === 'image' ? 'image-glow' : ''}" />`}
        </div>` : '';

      postEl.innerHTML = `
        <div class="post-header">
          ${avatarHtml}
          <div class="post-info">
            <a href="user-profile.html?uid=${post.authorId || ''}" style="text-decoration: none; color: inherit;">
                <div class="post-author">${post.author || "Anonymous"}</div>
            </a>
            <div class="post-time">${formatTimestamp(post.createdAt)}</div>
          </div>
          ${ownerActionsHtml}
        </div>
        ${post.description ? `<div class="post-content" data-searchable-content>${formatPostContent(post.description)}</div>` : '<div class="post-content" data-searchable-content style="display:none;"></div>'}
        ${mediaHtml}
        <div class="post-stats">
          <span class="likes-count">${likesDisplayHtml}</span>
          <span class="comments-count">${commentsDisplayHtml}</span>
        </div>
        <div class="post-actions">
          <button class="action-button like-button ${hasLiked ? 'liked' : ''}" data-post-id="${post.id}">
            <span class="material-icons${hasLiked ? '' : '-outlined'}">${hasLiked ? 'thumb_up' : 'thumb_up_off_alt'}</span>
            <span>Like</span>
          </button>
          <button class="action-button comment-button" data-post-id="${post.id}">
            <span class="material-icons-outlined">chat_bubble_outline</span>
            <span>Comment</span>
          </button>
        </div>
        <div class="comments-section" data-post-id="${post.id}">
           <div class="comments-list"><div style="text-align:center; padding:10px;"><div class="loading-spinner comment-spinner" style="width:20px; height:20px; border-width: 2px; display:none;"></div></div></div>
        </div>
        ${currentUser ? `
        <div class="comment-input-area">
          <div class="post-avatar comment-avatar">
             <a href="user-profile.html?uid=${currentUserProfile?.uid || ''}"><img src="${commentAvatarUrl}" alt="Your Avatar"></a>
          </div>
          <input type="text" class="comment-input" placeholder="Write a comment..." data-post-id="${post.id}" aria-label="Write a comment">
          <button class="comment-submit-btn disabled" data-post-id="${post.id}" aria-label="Send Comment"><span class="material-icons">send</span></button>
        </div>` : '' }`;

      const commentButton = postEl.querySelector('.comment-button');
      const commentsSection = postEl.querySelector('.comments-section');
      if (commentButton && commentsSection) {
        commentButton.addEventListener('click', () => toggleComments(post.id, commentsSection));
      }
      return postEl;
    }
    function toggleComments(postId, commentsSection) { /* ... (no changes) ... */
        const commentsList = commentsSection.querySelector('.comments-list');
        const isVisible = commentsSection.classList.contains('visible');
        if (!isVisible) {
            commentsSection.classList.add('visible');
            commentsSection.style.maxHeight = '500px'; 
             if (!commentsList.dataset.loaded) { 
                 loadCommentsForPost(postId, commentsList, commentsSection);
             } else {
                  commentsSection.style.maxHeight = commentsList.scrollHeight + 'px';
             }
            const inputField = postList.querySelector(`.comment-input[data-post-id="${postId}"]`);
            if (inputField) inputField.focus();
        } else {
            commentsSection.classList.remove('visible');
            commentsSection.style.maxHeight = '0';
        }
    }
    async function loadCommentsForPost(postId, commentsContainer, commentsSectionElement) { /* ... (no changes) ... */
        if (!db) return;
        const spinner = commentsContainer.querySelector('.comment-spinner');
        if (spinner) spinner.style.display = 'inline-block';
        try {
            const commentsRef = collection(doc(db, "social", postId), "comments");
            const q = query(commentsRef, orderBy("createdAt", "desc"), limit(5)); 
            const snapshot = await getDocs(q);
            commentsContainer.innerHTML = ''; 
            if (snapshot.empty) {
                commentsContainer.innerHTML = '<p style="color: var(--text-secondary); font-size: 0.8rem; text-align:center; padding: 10px 0;">No comments yet.</p>';
            } else {
                snapshot.docs.forEach(docSnap => renderComment(docSnap.data(), commentsContainer));
            }
            commentsContainer.dataset.loaded = "true"; 
            if (commentsSectionElement && commentsSectionElement.classList.contains('visible')) {
                 commentsSectionElement.style.maxHeight = commentsContainer.scrollHeight + 'px';
            }
        } catch (error) {
            console.error(`Error loading comments for post ${postId}:`, error);
            commentsContainer.innerHTML = '<p style="color: red; font-size: 0.8rem; text-align: center;">Could not load comments.</p>';
        } finally {
            if (spinner) spinner.style.display = 'none';
        }
    }
    function renderComment(commentData, container) { /* ... (no changes) ... */
        const commentEl = document.createElement('div');
        commentEl.className = 'comment';
        commentEl.innerHTML = `
            <div class="comment-avatar">
              <a href="user-profile.html?uid=${commentData.authorId || ''}"><img src="${commentData.authorAvatarUrl || 'assets/images/user.png'}" alt="${commentData.authorName || 'User'} Avatar"></a>
            </div>
            <div class="comment-content">
              <a href="user-profile.html?uid=${commentData.authorId || ''}" style="text-decoration: none; color: inherit;"><div class="comment-author">${commentData.authorName || 'Anonymous'}</div></a>
              <div class="comment-text">${formatPostContent(commentData.text)}</div>
              <div class="comment-time">${formatTimestamp(commentData.createdAt)}</div>
            </div>`;
        container.prepend(commentEl); 
    }

    async function uploadMediaToFirebase(file, pathPrefix = 'posts') {
        if (!storage || !currentUser) { showNotification("Cannot upload media. Login required or storage unavailable."); return null; }
        const uidForPath = currentUser.uid;
        try {
            const fileRef = storageRef(storage, `${pathPrefix}/${uidForPath}/${Date.now()}_${file.name}`);
            const snapshot = await uploadBytes(fileRef, file);
            return await getDownloadURL(snapshot.ref);
        } catch (error) {
            console.error("Firebase Storage upload error:", error);
            showNotification(`Media upload failed: ${error.message}`);
            return null;
        }
    }
    async function handleLike(postId, button) { /* ... (no changes) ... */
        if (!currentUser || !db) { showNotification("Please log in to like posts."); return; }
        const postRef = doc(db, "social", postId);
        const likeRef = doc(postRef, "likes", currentUser.uid);
        const isCurrentlyLiked = userLikes[postId] === true;
        const originalLikeState = userLikes[postId];
        const postDataFromGlobal = postsDataGlobal[postId]; 
        const originalLikeCount = postDataFromGlobal?.likeCount || 0;
        userLikes[postId] = !isCurrentlyLiked;
        if (postDataFromGlobal) {
            postDataFromGlobal.likeCount = originalLikeCount + (userLikes[postId] ? 1 : -1);
        }
        updateLikeButtonUI(postId, userLikes[postId]);
        button.disabled = true;

        try {
            await runTransaction(db, async (transaction) => {
                const postDoc = await transaction.get(postRef);
                if (!postDoc.exists()) throw "Document does not exist!";
                let currentDbLikeCount = postDoc.data().likeCount || 0;
                const likeDoc = await transaction.get(likeRef);

                if (!isCurrentlyLiked && !likeDoc.exists()) {
                    transaction.set(likeRef, { createdAt: serverTimestamp() });
                    transaction.update(postRef, { likeCount: currentDbLikeCount + 1 });
                } else if (isCurrentlyLiked && likeDoc.exists()) {
                    transaction.delete(likeRef);
                    transaction.update(postRef, { likeCount: Math.max(0, currentDbLikeCount - 1) });
                } else {
                    console.warn(`Like state mismatch for post ${postId}. UI: ${isCurrentlyLiked}, DB: ${likeDoc.exists()}. Syncing...`);
                    userLikes[postId] = likeDoc.exists(); 
                    if (postDataFromGlobal) postDataFromGlobal.likeCount = currentDbLikeCount;
                    updateLikeButtonUI(postId, userLikes[postId]); 
                    throw new Error("Syncing like state.");
                }
            });
        } catch (error) {
            if (error.message !== "Syncing like state.") { 
                console.error("Like transaction failed:", error);
                showNotification(`Could not ${isCurrentlyLiked ? 'unlike' : 'like'} post.`);
                userLikes[postId] = originalLikeState;
                if (postDataFromGlobal) postDataFromGlobal.likeCount = originalLikeCount;
                updateLikeButtonUI(postId, userLikes[postId]);
            }
        } finally {
            button.disabled = false; 
        }
    }
    async function handleCommentSubmit(postId, text, inputField, submitButton) { /* ... (no changes) ... */
        if (!currentUser || !db || !currentUserProfile) { showNotification("Login and profile required to comment."); return; }
        const postRef = doc(db, "social", postId);
        const commentsRef = collection(postRef, "comments");
        inputField.disabled = true; submitButton.disabled = true; submitButton.classList.add('disabled');

        const newCommentData = {
            text: text,
            authorId: currentUserProfile.uid,
            authorName: currentUserProfile.displayName || "Anonymous",
            authorAvatarUrl: currentUserProfile.photo || 'assets/images/user.png',
            createdAt: serverTimestamp()
        };
        try {
            const addedCommentRef = await addDoc(commentsRef, newCommentData);
            await runTransaction(db, async (transaction) => {
                const postDoc = await transaction.get(postRef);
                if (!postDoc.exists()) throw "Post document does not exist!";
                const newCommentCount = (postDoc.data().commentCount || 0) + 1;
                transaction.update(postRef, { commentCount: newCommentCount });
                if (postsDataGlobal[postId]) postsDataGlobal[postId].commentCount = newCommentCount;
            });
            
            inputField.value = ""; 
            const commentsList = postList.querySelector(`.comments-section[data-post-id="${postId}"] .comments-list`);
            if (commentsList) {
                 const optimisticCommentData = { ...newCommentData, createdAt: { toDate: () => new Date() }}; 
                 renderComment(optimisticCommentData, commentsList); 
                 const commentsSection = commentsList.closest('.comments-section');
                 if (commentsSection && !commentsSection.classList.contains('visible')) {
                     toggleComments(postId, commentsSection); 
                 } else if (commentsSection) {
                     commentsSection.style.maxHeight = commentsList.scrollHeight + 'px'; 
                 }
            }
            updateCommentCountUI(postId); 
            showNotification("Comment posted!");
        } catch (error) {
            console.error("Error adding comment:", error);
            showNotification("Could not post comment. Please try again.");
        } finally {
            inputField.disabled = false; 
        }
    }
    async function handleCreatePost() {
        if (!currentUser || !db || !currentUserProfile) { showNotification("Login and profile required to post."); return; }
        const descVal = formPostDescriptionEl.value.trim();
        
        // Use mediaFileForUpload instead of formPostMediaFileEl.files[0]
        const fileToUpload = mediaFileForUpload; 

        if (!descVal && !fileToUpload) { showNotification("Please write something or add/generate media."); return; }

        formSubmitPostBtn.disabled = true;
        formSubmitPostBtn.innerHTML = 'Posting... <span class="upload-spinner-inline"></span>';
        let mediaUrl = "", mediaType = "";

        if (fileToUpload) {
            // If video trimming was conceptually applied, you might adjust fileToUpload here or send trim parameters.
            // For now, we upload the file as is.
            // let actualFileToUpload = fileToUpload;
            // if (fileToUpload.type.startsWith("video/") && trimStartTimeSlider.value !== '0' && trimEndTimeSlider.value !== trimEndTimeSlider.max) {
            //   showNotification("Video trimming selected. Note: Actual client-side trimming for upload requires dedicated libraries. Full video will be uploaded unless integrated.");
            //   // Here, if ffmpeg.wasm or similar was used, `actualFileToUpload` would be the trimmed Blob/File.
            // }
            mediaUrl = await uploadMediaToFirebase(fileToUpload, 'posts');
            if (!mediaUrl) {
                formSubmitPostBtn.disabled = false;
                formSubmitPostBtn.innerHTML = "Post";
                return;
            }
            mediaType = fileToUpload.type.startsWith("video") ? "video" : (fileToUpload.type.startsWith("image") ? "image" : "file");
        }
        try {
            await addDoc(collection(db, "social"), {
                description: descVal, mediaUrl, mediaType,
                author: currentUserProfile.displayName || "Anonymous",
                authorId: currentUserProfile.uid,
                authorAvatarUrl: currentUserProfile.photo || 'assets/images/user.png',
                createdAt: serverTimestamp(), likeCount: 0, commentCount: 0
            });
            if (formPostDescriptionEl) formPostDescriptionEl.value = "";
            
            // Reset media related elements
            mediaFileForUpload = null;
            formPostMediaFileEl.value = ""; // Clear the actual file input
            mediaPreviewContainer.innerHTML = '';
            mediaPreviewContainer.style.display = 'none';
            mediaEnhancementControlsEl.style.display = 'none'; // Hide enhancement controls
            imageBeautifyControlsEl.style.display = 'none';
            videoEnhancementControlsContainerEl.style.display = 'none';
            videoTrimControlsEl.style.display = 'none';
            originalImageForBeautify = null;
            currentPreviewType = null;


            showNotification("Post created successfully!");
            await loadPosts(); 
            const currentSearchTerm = headerSearchInputEl?.value;
            if (currentSearchTerm && currentSearchTerm.trim() !== '') {
                filterPostsOnPage(currentSearchTerm.toLowerCase().trim());
            }

        } catch (error) {
            console.error("Error creating post:", error);
            showNotification(`Failed to create post: ${error.message}`);
        } finally {
            formSubmitPostBtn.disabled = false;
            formSubmitPostBtn.innerHTML = "Post";
        }
    }
     window.handleEditPost = (postId) => { /* ... (no changes) ... */
         if (!currentUser || !postsDataGlobal[postId] || postsDataGlobal[postId].authorId !== currentUser.uid) {
             showNotification("You can only edit your own posts."); return;
         }
         editPostId = postId;
         editPostDescriptionEl.value = postsDataGlobal[postId].description || "";
         if (editModalUserAvatar && currentUserProfile) editModalUserAvatar.src = currentUserProfile.photo || 'assets/images/user.png';
         editPostModal.classList.add("active");
     };
     async function handleUpdatePost() { /* ... (no changes) ... */
         if (!editPostId || !currentUser || !db || !postsDataGlobal[editPostId] || postsDataGlobal[editPostId].authorId !== currentUser.uid) {
             showNotification("Error: Cannot update this post."); return;
         }
         updatePostBtn.disabled = true; updatePostBtn.textContent = "Updating...";
         try {
             await updateDoc(doc(db, "social", editPostId), {
                 description: editPostDescriptionEl.value.trim(),
                 updatedAt: serverTimestamp()
             });
             showNotification("Post updated successfully.");
             editPostModal.classList.remove("active");
             postsDataGlobal[editPostId].description = editPostDescriptionEl.value.trim(); 
             const postCardContent = postList.querySelector(`.post-card[data-post-id="${editPostId}"] .post-content`);
             if (postCardContent) postCardContent.innerHTML = formatPostContent(editPostDescriptionEl.value.trim());
             editPostId = null;
         } catch (error) {
             console.error("Error updating post:", error);
             showNotification("Could not update post.");
         } finally { updatePostBtn.disabled = false; updatePostBtn.textContent = "Update"; }
     }
     window.handleDeletePost = async (postId) => { /* ... (no changes) ... */
        if (!currentUser || !db || !postsDataGlobal[postId] || postsDataGlobal[postId].authorId !== currentUser.uid) {
            showNotification("You can only delete your own posts."); return;
        }
        if (confirm("Are you sure you want to delete this post? This cannot be undone.")) {
            const postCardEl = postList.querySelector(`.post-card[data-post-id="${postId}"]`);
            if (postCardEl) postCardEl.style.opacity = '0.5'; 
            try {
                await deleteDoc(doc(db, "social", postId));
                showNotification("Post deleted successfully.");
                if (postCardEl) postCardEl.remove();
                delete postsDataGlobal[postId]; 
                if (postList && postList.children.length === 0 && !headerSearchInputEl?.value) { 
                    showEmptyState();
                } else if (postList && postList.querySelectorAll('.post-card:not(.hidden-by-search)').length === 0 && headerSearchInputEl?.value) {
                    filterPostsOnPage(headerSearchInputEl.value.toLowerCase().trim());
                }

            } catch (error) {
                console.error("Error deleting post:", error);
                showNotification("Could not delete post.");
                 if (postCardEl) postCardEl.style.opacity = '1'; 
            }
        }
     };
    function updateLikeButtonUI(postId, isLiked) { /* ... (no changes) ... */
        const postCards = postList?.querySelectorAll(`.post-card[data-post-id="${postId}"]`);
        postCards?.forEach(postCard => {
            const likeButton = postCard.querySelector('.like-button');
            const icon = likeButton?.querySelector('.material-icons, .material-icons-outlined');
            const likeCountSpan = postCard.querySelector('.post-stats .likes-count');
            
            if (likeButton && icon) {
                likeButton.classList.toggle('liked', isLiked);
                icon.textContent = isLiked ? 'thumb_up' : 'thumb_up_off_alt';
                icon.className = isLiked ? 'material-icons' : 'material-icons-outlined'; 
            }
            const count = postsDataGlobal[postId]?.likeCount || 0;
            if (likeCountSpan) {
                 const likeIconHtml = `<span class="material-icons like-icon-filled" style="font-size: 0.9rem; vertical-align: middle; margin-right: 2px;">thumb_up</span>`;
                 likeCountSpan.innerHTML = count > 0 ? `${likeIconHtml} ${count}` : '';
            }
        });
    }
    function updateCommentCountUI(postId) { /* ... (no changes) ... */
        const postCards = postList?.querySelectorAll(`.post-card[data-post-id="${postId}"]`);
        postCards?.forEach(postCard => {
            const commentCountSpan = postCard.querySelector('.post-stats .comments-count');
             if (!commentCountSpan) return;
             const count = postsDataGlobal[postId]?.commentCount || 0;
             commentCountSpan.textContent = count > 0 ? `${count} Comment${count > 1 ? 's' : ''}` : '';
        });
    }

    headerSearchInputEl?.addEventListener('input', function() {
        const searchTerm = this.value.toLowerCase().trim();
        filterPostsOnPage(searchTerm);
    });

    function filterPostsOnPage(searchTerm) {
        const allPostCards = postList.querySelectorAll('.post-card');
        let searchEmptyEl = document.getElementById('searchEmptyStateInList'); 

        if (searchTerm === '') {
            allPostCards.forEach(post => post.classList.remove('hidden-by-search'));
            if (searchEmptyEl) searchEmptyEl.style.display = 'none'; 
            if (Object.keys(postsDataGlobal).length === 0) {
                showEmptyState();
            } else {
                hideEmptyState(); 
            }
            return;
        }
        let visiblePostsCount = 0;
        hideEmptyState(); 
        allPostCards.forEach(post => {
            const contentEl = post.querySelector('.post-content[data-searchable-content]');
            const authorEl = post.querySelector('.post-author');
            const postDescription = contentEl ? contentEl.textContent.toLowerCase() : '';
            const postAuthor = authorEl ? authorEl.textContent.toLowerCase() : '';
            const isMatch = postDescription.includes(searchTerm) || postAuthor.includes(searchTerm);
            if (isMatch) {
                post.classList.remove('hidden-by-search');
                visiblePostsCount++;
            } else {
                post.classList.add('hidden-by-search');
            }
        });
        if (visiblePostsCount === 0) {
            if (!searchEmptyEl) {
                searchEmptyEl = document.createElement('div');
                searchEmptyEl.id = 'searchEmptyStateInList';
                searchEmptyEl.className = 'empty-state'; 
                postList.appendChild(searchEmptyEl); 
            }
            searchEmptyEl.style.display = 'block';
            searchEmptyEl.innerHTML = `
                <i class="material-icons">search_off</i>
                <h3>No posts match "<strong>${escapeHTML(searchTerm)}</strong>"</h3>
                <p>Try a different search term or clear the search.</p>
            `;
        } else {
            if (searchEmptyEl) searchEmptyEl.style.display = 'none';
        }
    }

    onAuthStateChanged(auth, async (user) => {
      loadingOverlay?.classList.add('active');
      if (user) {
        currentUser = user;
        try {
            const userDocRef = doc(db, "users", user.uid);
            const userDocSnap = await getDoc(userDocRef);
            if (userDocSnap.exists()) {
                currentUserProfile = { uid: user.uid, ...userDocSnap.data() };
            } else { 
                currentUserProfile = { uid: user.uid, displayName: user.displayName || user.email?.split('@')[0] || "User", photo: user.photoURL || 'assets/images/user.png' };
                console.warn("Firestore user profile not found for UID:", user.uid, "Using Auth data.");
            }
        } catch (error) {
            console.error("Error fetching user profile:", error);
            currentUserProfile = { uid: user.uid, displayName: user.displayName || user.email?.split('@')[0] || "User", photo: user.photoURL || 'assets/images/user.png' };
        }
        updateUserAvatars(currentUserProfile);
        await loadConnects();
        await loadPosts(); 
      } else { 
        currentUser = null; currentUserProfile = null; userLikes = {}; postsDataGlobal = {};
        updateUserAvatars(null);
        clearConnects();
        postList.innerHTML = ""; 
        const searchEmptyEl = document.getElementById('searchEmptyStateInList');
        if (searchEmptyEl) searchEmptyEl.style.display = 'none';
        showEmptyState("Please log in to see the feed.", "Your social world awaits!");
        loadingOverlay?.classList.remove('active');
      }
    });

    formPostMediaFileEl?.addEventListener('change', function(event) {
        const file = event.target.files[0];
        if (!mediaPreviewContainer) return;
        
        if (file) {
            displayMediaPreview(file); // This now sets mediaFileForUpload
        } else {
            mediaPreviewContainer.innerHTML = '';
            mediaPreviewContainer.style.display = 'none';
            mediaEnhancementControlsEl.style.display = 'none';
            mediaFileForUpload = null;
            originalImageForBeautify = null;
            currentPreviewType = null;
        }
    });

    formSubmitPostBtn?.addEventListener("click", handleCreatePost);
    editModalClose?.addEventListener("click", () => { editPostModal.classList.remove("active"); editPostId = null; });
    updatePostBtn?.addEventListener('click', handleUpdatePost);
    editPostModal?.addEventListener('click', (e) => { if (e.target === editPostModal) { editPostModal.classList.remove('active'); editPostId = null; } });
    createConnectCard?.addEventListener('click', () => {
      if (!currentUser) { showNotification("Please log in to create a connect."); return; }
      connectFileInput?.click();
    });
    connectFileInput?.addEventListener('change', (event) => {
      const file = event.target.files[0];
      if (file) createConnect(file);
    });

    postList?.addEventListener('click', (e) => {
      const likeButton = e.target.closest('.like-button');
      if (likeButton) { handleLike(likeButton.dataset.postId, likeButton); }

      const submitButton = e.target.closest('.comment-submit-btn');
      if (submitButton && !submitButton.classList.contains('disabled')) {
        if (!currentUser) { showNotification("Please log in to comment."); return; }
        const postId = submitButton.dataset.postId;
        const inputField = submitButton.closest('.comment-input-area')?.querySelector(`.comment-input[data-post-id="${postId}"]`);
        if (inputField) {
          const commentText = inputField.value.trim();
          if (commentText) handleCommentSubmit(postId, commentText, inputField, submitButton);
        }
      }
    });
    postList?.addEventListener('input', (e) => {
      const inputField = e.target.closest('.comment-input');
      if (inputField) {
        const submitButton = inputField.closest('.comment-input-area')?.querySelector(`.comment-submit-btn[data-post-id="${inputField.dataset.postId}"]`);
        if (submitButton) {
          const hasText = inputField.value.trim().length > 0;
          submitButton.classList.toggle('disabled', !hasText);
          submitButton.disabled = !hasText;
        }
      }
    });
  </script>
</body>
</html><script>
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('/service-worker.js')
        .then(registration => {
          console.log('Service Worker registered with scope:', registration.scope);
        })
        .catch(error => {
          console.error('Service worker registration failed:', error);
        });
    }
  <\/script>
